\documentclass[german]{../spicker}

\usepackage{amsmath}

\usepackage{graphicx}
\usepackage{tabularx, multirow}
\usepackage{forest}

\usetikzlibrary{tikzmark,calc,arrows.meta,chains,decorations.pathreplacing,scopes,shapes.misc,shapes.multipart}

\tikzset{
    weight/.style = {
        scale=0.7,
        },
    prim node/.style = {
        fill = blue!50,
        text = white,
        },
    prim edge/.style = {
        draw=blue,
        very thick,
        },
    current/.style = {
        fill = teal!50,
        },
    visited/.style = {
        fill = teal!30,
        %text=white,
        opacity = 0.5,
    },
}

\forestset{%
empty node/.style = {
    dashed,
    opacity = .2, 
    fill opacity = 0.2,
    edge = {opacity=.2},
    },
r/.style = {
    fill = red!50,
    text=white,
    draw=red,
    calign angle=30,
    calign=fixed edge angles,
    %fill opacity = 0.5,
},
b/.style = {
    fill = black!50,
    text=white,
    draw=black,
    calign angle=30,
    calign=fixed edge angles,
    %fill opacity = 0.5,
},
rbn/.style = { %red black not defined
    fill = blue!50,
    text=white,
    draw=black,
    calign angle=30,
    calign=fixed edge angles,
    %fill opacity = 0.5,
},
nil/.style = {
    fill = black!50,
    minimum size=1em,
    calign angle=30,
    calign=fixed edge angles,
    %fill opacity = 0.5,
},
mpn/.style args = {#1/#2/#3/#4}{draw,
rectangle split, rectangle split horizontal,
rectangle split parts=4,
on chain=A,
draw=black!50,
node contents={ \nodepart{one}    $#1$
                \nodepart{two}    $#2$
                \nodepart{three}  $#3$
                \nodepart{four}   $#4$}
                            },
}

\newcommand\mpnc[4]{\nodepart{one}      $#1$
                    \nodepart{two}      $#2$                    
                    \nodepart{three}    $#3$
                    \nodepart{four}     $#4$
                    }

\addbibresource{algo.bib}

\title{Algorithmen}
\author{Patrick Gustav Blaneck}
\makeindex[intoc]
\makeindex[intoc, name=Beispiele,title=Beispiele]

\newenvironment{allintypewriter}{\ttfamily}{\par}

\newcommand{\BF}{\operatorname{BF}} 
\newcommand{\vektor}[1]{\begin{pmatrix*}[c] #1 \end{pmatrix*}}

\pgfmathsetmacro\twopi{2*pi}

\pgfmathdeclarefunction{lngamma}{1}{%
  \pgfmathsetmacro\lngammatmp{#1*#1*#1}%
  \pgfmathparse{%
    #1*ln(#1) - #1 - .5*ln(#1/\twopi)
    + 1/12/#1 - 1/360/\lngammatmp + 1/1260/\lngammatmp/#1/#1
  }%
}  

\pgfmathdeclarefunction{facreal}{1}{%
  \pgfmathparse{exp(lngamma(#1+1))}% 
}

\begin{document}
\maketitle
\tableofcontents
\newpage

%\setcounter{section}{1}

\section{Grundbegriffe}
\begin{defi}{Eigenschaften eines Algorithmus}
    \begin{itemize}
        \item \emph{Terminierung:} Der Algorithmus bricht nach \emph{endlichen vielen} Schritten ab.
        \item \emph{Determiniertheit:} Bei vorgegebener Eingabe wird ein eindeutiges \emph{Ergebnis} geliefert.
        \item \emph{Determinismus:} Eindeutige Vorgabe der \emph{Abfolge} der auszuführenden Schritte
    \end{itemize}
\end{defi}

\begin{defi}{Landau-Notation}
    Seien $f, g$ reellwertige Funktionen der reellen Zahlen.
    Dann gilt: \cite{wiki:Landau-Symbole}

    \begin{tabular}{l|l|l}
        Notation          & Definition       & Mathematische Definition                                                                                                  \\
        \hline
        $f \in \bigo(g)$  & obere Schranke   & $\exists C > 0 \exists x_0 > 0 \forall x > x_0 : \abs{f(x)} \leq C \cdot \abs{g(x)}$                                      \\
        $f \in \Omega(g)$ & untere Schranke  & $\exists c > 0 \exists x_0 > 0 \forall x > x_0 : c\cdot \abs{g(x)} \leq \abs{f(x)}$                                       \\
        $f \in \Theta(g)$ & scharfe Schranke & $\exists c > 0 \exists C > 0 \exists x_0 > 0 \forall x > x_0 : c\cdot \abs{g(x)} \leq \abs{f(x)} \leq C \cdot \abs{g(x)}$ \\
    \end{tabular}

    Anschaulicher gilt:

    \begin{tabular}{l|l}
        Notation          & Anschauliche Bedeutung                        \\
        \hline
        $f \in \bigo(g)$  & $f$ wächst nicht wesentlich schneller als $g$ \\
        $f \in \Omega(g)$ & $f$ wächst nicht wesentlich langsamer als $g$ \\
        $f \in \Theta(g)$ & $f$ wächst genauso schnell wie $g$
    \end{tabular}
\end{defi}

\begin{example}{Landau-Notation}
    Aus \cite{wiki:Landau-Symbole} :

    \begin{tabular}{l|l}
        Notation                & Beispiel                                          \\
        \hline
        $f \in \bigo(1)$        & Feststellen, ob eine Binärzahl gerade ist         \\
        $f \in \bigo(\log n)$   & Binäre Suche im sortierten Feld mit $n$ Einträgen \\
        $f \in \bigo(\sqrt{n})$ & Anzahl der Divisionen des naiven Primzahltests    \\
        $f \in \bigo(n)$        & Suche im unsortierten Feld mit $n$ Einträgen      \\
        $f \in \bigo(n\log n)$  & Mergesort, Heapsort                               \\
        $f \in \bigo(n^2)$      & Selectionsort                                     \\
        $f \in \bigo(n^m)$      &                                                   \\
        $f \in \bigo(2^{cn})$   & (Backtracking)                                    \\
        $f \in \bigo(n!)$       & Traveling Salesman Problem
    \end{tabular}
\end{example}

\begin{bonus}{Visualisierung Komplexitätsklassen}
    \begin{center}
        \begin{tikzpicture}[scale=1]
            \begin{axis}[
                    %view={45}{15},
                    width=15cm,
                    unit vector ratio*=1 1,
                    axis lines = middle,
                    grid=major,
                    ymin=0,
                    ymax=50,
                    xmin=0,
                    xmax=50,
                    %zmin=-1,
                    %zmax=10,
                    xlabel = $n$,
                    ylabel = $N$,
                    %zlabel = $z$,
                    %xtick style={draw=none},
                    %ytick style={draw=none},
                    %ztick style={draw=none},
                    xtick distance={5},
                    ytick distance={5},
                    %ztick distance={1},
                    %xticklabels=\empty,
                    %yticklabels=\empty,
                    %zticklabels=\empty,
                    disabledatascaling,
                    %stack dir=minus,
                    cycle list name=color list,
                    samples=250,
                    solid,
                    smooth,
                    line width=1.0pt,
                    no markers,
                    legend cell align={left},
                    reverse legend,
                ]

                \addplot +[domain=0:50]{0};         \addlegendentry{$\bigo(1)$};
                \addplot +[domain=0:50]{ln(x)};     \addlegendentry{$\bigo(\log(n))$};
                \addplot +[domain=0:50]{sqrt(x)};   \addlegendentry{$\bigo(\sqrt{n})$};
                \addplot +[domain=0:50]{x};         \addlegendentry{$\bigo(n)$};
                \addplot +[domain=0:50]{x * ln(x)}; \addlegendentry{$\bigo(n \log(n))$};
                \addplot +[domain=0:50]{x^2};       \addlegendentry{$\bigo(n^2)$};
                \addplot +[domain=0:10]{2^x};        \addlegendentry{$\bigo(2^n)$};
                \addplot +[domain=0:5]{facreal(x)}; \addlegendentry{$\bigo(n!)$};
            \end{axis}
        \end{tikzpicture}
    \end{center}
\end{bonus}

\section{Elementare Datenstrukturen}

\begin{defi}{Homogene Datenstruktur}
    In einer \emph{homogenen Datenstruktur} haben alle Komponenten den \emph{gleichen} Datentyp.
\end{defi}

\begin{defi}{Heterogene Datenstruktur}
    In einer \emph{heterogenen Datenstruktur} haben die Komponenten \emph{unterschiedliche} Datentypen.
\end{defi}

% ADTs
\begin{defi}{Abstrakte Datentypen (ADTs)}
    Anforderungen an die Definition eines Datentyps:
    \begin{itemize}
        \item \emph{Spezifikation} eines Datentyps unabhängig von der Implementierung
        \item Reduzierung der von außen sichtbaren Aspekte auf die \emph{Schnittstelle} des Datentyps
    \end{itemize}

    Daraus entstehen \textbf{zwei Prinzipien}:
    \begin{itemize}
        \item \emph{Kapselung:}
              \subitem Zu einem ADT gehört eine Schnittstelle.
              \subitem Zugriffe auf den ADT erfolgen ausschließlich über die Schnittstelle.
        \item \emph{Geheimnisprinzip:}
              \subitem Interne Realisierung eines ADT-Moduls bleibt verborgen.
    \end{itemize}
\end{defi}

\begin{bonus}{ADTs in Java}
    Viele wichtige abstrakte Datentypen werden in Java durch \emph{Interfaces} beschrieben.

    Es gibt ein oder mehrere Implementierungen dieser Interfaces mit unterschiedlichen dahinter stehenden Konzepten.

    In Java: Package \texttt{java.util}

    Wichtig in der Vorlesung:

    \begin{tabular}{l|l|l}
        ADT                     & Grund-ADT/Interface & Java-Klassen                      \\
        \hline
        Feld                    &                     & (Felder), HashMap                 \\
        Liste                   & List                & ArrayList, LinkedList             \\
        Menge                   & Set                 & HashSet, TreeSet                  \\
        Prioritätswarteschlange &                     & PriorityQueue                     \\
        Stack                   & List                &                                   \\
        Queue                   & List                &                                   \\
        Deque                   & List                & Deque (Interface), ArrayDeque     \\
        Map                     & Set                 & Map (Interface), HashMap, TreeMap \\
        BidiMap                 & Map                 & BidiMap, BiMap (Interface)        \\
        MultiSet, Bag           & Map                 & Bag, Multiset (Interface)
    \end{tabular}
\end{bonus}

\subsection{Felder und abstrakte Datenstrukturen}

\begin{defi}{Array}
    Ein \emph{Array} hat folgende spezielle Eigenschaften:
    \begin{itemize}
        \item Feste Anzahl an Datenobjekten
        \item Auf jedes Objekt kann direkt lesend oder schreibend zugegriffen werden
    \end{itemize}

    \begin{center}
        \begin{tikzpicture}[
                %  -{Stealth[length = 2.5pt]},
                start chain,
                node distance = 0pt,
                StackBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain},
            ]
            { start chain = going right
                \node [StackBlock, label=$0$] (0) {};
                \node [StackBlock, label=$1$] (1) {};
                \node [StackBlock, label=$2$] (2) {};
                \node [StackBlock, label=$3$] (3) {};
                \node [StackBlock, label=$\ldots$] (d1) {};
                \node [StackBlock, label=$k$] (k) {};
                \node [StackBlock, label=$\ldots$] (d2) {};
                \node [StackBlock, label=$n-1$] (n1) {};
                \node [StackBlock, label=$n$] (n) {};
            }
        \end{tikzpicture}
    \end{center}

    \textbf{Performance:}

    \begin{center}
        \begin{tabular}{c|c|c|c|c}
            Zugriff     & Suche       & Einf./Lösch. (Anfang) & Einf./Lösch. (Ende) & Einf./Lösch. (Mitte) \\
            \hline
            $\Theta(1)$ & $\Theta(n)$ & -                     & -                   & -                    \\
        \end{tabular}
    \end{center}
\end{defi}


\begin{defi}{Stack}
    \begin{itemize}
        \item Daten können an einem Ende hinzugefügt oder entnommen werden.
    \end{itemize}

    \begin{center}
        \begin{tikzpicture}[
                %  -{Stealth[length = 2.5pt]},
                start chain,
                node distance = 0pt,
                StackBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain},
            ]
            { start chain = going right
                \node [StackBlock,draw=none] (0) {};

                \node [StackBlock,xshift=4em] (1) {};
                \node [StackBlock] (2) {};
                \node [StackBlock] (3) {};
                \node [StackBlock] (4) {};
                \node [StackBlock] (5) {};

                \node [StackBlock,xshift=4em,draw=none] (6) {};

                \draw[->] ([yshift=0.5em, xshift=0.25em] 5.east) [out=0, in=180] to ([yshift=0.5em, xshift=-0.25em] 6.west);
                \draw[->] ([yshift=-0.5em, xshift=-0.25em] 6.west) [out=180, in=0] to ([yshift=-0.5em, xshift=0.25em] 5.east);
            }
        \end{tikzpicture}
    \end{center}
\end{defi}

\begin{defi}{Queue}
    \begin{itemize}
        \item Daten können an einem Ende hinzugefügt und am anderen Ende entnommen werden.
    \end{itemize}

    \begin{center}
        \begin{tikzpicture}[
                %  -{Stealth[length = 2.5pt]},
                start chain,
                node distance = 0pt,
                StackBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain},
            ]
            { start chain = going right
                \node [StackBlock,draw=none] (0) {};

                \node [StackBlock,xshift=4em] (1) {};
                \node [StackBlock] (2) {};
                \node [StackBlock] (3) {};
                \node [StackBlock] (4) {};
                \node [StackBlock] (5) {};

                \node [StackBlock,xshift=4em,draw=none] (6) {};

                \draw[<-] ([xshift=0.25em] 0.east) [out=0, in=180] to ([xshift=-0.25em] 1.west);
                \draw[->] ([xshift=-0.25em] 6.west) [out=180, in=0] to ([xshift=0.25em] 5.east);
            }
        \end{tikzpicture}
    \end{center}
\end{defi}

\begin{defi}{Deque (\glqq Double ended queue\grqq)}
    \begin{itemize}
        \item Daten können an beiden Enden hinzugefügt und entnommen werden.
    \end{itemize}

    \begin{center}
        \begin{tikzpicture}[
                %  -{Stealth[length = 2.5pt]},
                start chain,
                node distance = 0pt,
                StackBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain},
            ]
            { start chain = going right
                \node [StackBlock,draw=none] (0) {};

                \node [StackBlock,xshift=4em] (1) {};
                \node [StackBlock] (2) {};
                \node [StackBlock] (3) {};
                \node [StackBlock] (4) {};
                \node [StackBlock] (5) {};

                \node [StackBlock,xshift=4em,draw=none] (6) {};

                \draw[->] ([yshift=0.5em, xshift=0.25em] 5.east) [out=0, in=180] to ([yshift=0.5em, xshift=-0.25em] 6.west);
                \draw[->] ([yshift=-0.5em, xshift=-0.25em] 6.west) [out=180, in=0] to ([yshift=-0.5em, xshift=0.25em] 5.east);

                \draw[<-] ([yshift=0.5em, xshift=0.25em] 0.east) [out=0, in=180] to ([yshift=0.5em, xshift=-0.25em] 1.west);
                \draw[<-] ([yshift=-0.5em, xshift=-0.25em] 1.west) [out=180, in=0] to ([yshift=-0.5em, xshift=0.25em] 0.east);
            }
        \end{tikzpicture}
    \end{center}
\end{defi}

% Dynamische Felder
\begin{defi}{Dynamisches Feld}
    Ein \emph{dynamisches Feld} besteht aus:
    \begin{itemize}
        \item Einem normalen Feld, das nicht vollständig gefüllt ist.
        \item Einem Zeiger, der anzeigt, welches das erste unbesetzte Element ist.
    \end{itemize}

    \begin{center}
        \begin{tikzpicture}[
            %  -{Stealth[length = 2.5pt]},
            start chain,
            node distance = 0pt,
            StackBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain},
            ]
            { start chain = going right
            \node [StackBlock, fill=red!50, label=$0$] (0) {};
            \node [StackBlock, fill=red!50, label=$1$] (1) {};
            \node [StackBlock, fill=red!50, label=$2$] (2) {};
            \node [StackBlock, fill=red!50, label=$3$] (3) {};
            \node [StackBlock, fill=red!50, label=$\ldots$] (d1) {};
            \node [StackBlock, label=$k$] (k) {};
            \node [StackBlock, label=$\ldots$] (d2) {};
            \node [StackBlock, label=$n-1$] (n1) {};
            \node [StackBlock, label=$n$] (n) {};

            { [continue chain = going below]
            \chainin (k);
            \node[StackBlock,yshift=-1em] (pointer) {$k$};
            \draw[->] (pointer.north) [out=90, in=-90] to (k.south);
            }

            }
            %\begin{scope}[-{Stealth[length = 2.5pt]}]
            %\draw (1.north) [out=25, in=155] to (2.north);
            %\draw (1.north) [out=30, in=155] to (3.north);
            %\draw (1.north) [out=35, in=155] to (4.north);
            %\draw (6.north) [out=40, in=155] to (6.north);
            %\end{scope}
            %\draw[decorate,decoration={brace, amplitude=10pt, raise=5pt, mirror}]
            %(2.south west) to node[black,midway,below= 15pt] {$k$-elements} (7.south east);%

        \end{tikzpicture}
    \end{center}

    \textbf{Performance:}

    \begin{center}
        \begin{tabular}{c|c|c|c|c}
            Zugriff     & Suche       & Einf./Lösch. (Anfang) & Einf./Lösch. (Ende)                                                                                     & Einf./Lösch. (Mitte) \\
            \hline
            $\Theta(1)$ & $\Theta(n)$ & $\Theta(n)$           & $\Theta(1)/\Theta(n)$\footnote{Wenn das Feld schon voll ist, muss der komplette Inhalt kopiert werden.} & $\Theta(n)$          \\
        \end{tabular}
    \end{center}

    Damit ist ein dynamisches Feld gut für einen \emph{Stack} geeignet!
\end{defi}

% Zirkuläre dynamische Felder
\begin{defi}{Zirkuläres (dynamisches) Feld}
    Ein \emph{zirkuläres Feld} besitzt einen Speicher fester Größe.
    Dabei speichern zwei Zeiger jeweils den Anfang (\texttt{head}) des Speichers, bzw. auf die nächste freie Speicheradresse (\texttt{tail}) im Speicher.

    Wird ein Element am Anfang \glqq abgearbeitet\grqq, bewegt sich \texttt{head} eine Position weiter.
    Wird ein Element am Ende eingefügt, bewegt sich \texttt{tail} eine Position weiter.
    \begin{center}
        \begin{tikzpicture}[
            %  -{Stealth[length = 2.5pt]},
            start chain,
            node distance = 0pt,
            StackBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain},
            ]
            { start chain = going right
            \node [StackBlock,label=above:$15$] (15) {};
            \node [StackBlock,label=above:$0$, fill=red!50] (0) {};
            \node [StackBlock,label=above:$1$, fill=red!50] (1) {};
            \node [StackBlock,label=above:$2$, fill=red!50] (2) {};
            \node [StackBlock,label=above:$3$, fill=red!50] (3) {};

            { [continue chain = going below]
            \chainin (3);
            \node [StackBlock,label=right:$4$, fill=red!50] (4) {};
            \node [StackBlock,label=right:$5$] (5) {};
            \node [StackBlock,label=below:$6$] (6) {};
            }

            { [continue chain = going left]
            \chainin (6);
            \node [StackBlock,label=below:$7$] (7) {};
            \node [StackBlock,label=below:$8$] (8) {};
            \node [StackBlock,label=below:$9$] (9) {};
            \node [StackBlock,label=below:$10$] (10) {};
            \node [StackBlock,label=below:$11$] (11) {};
            }

            { [continue chain = going above]
            \chainin (11);
            \node [StackBlock,label=left:$12$] (12) {};
            \node [StackBlock,label=left:$13$] (13) {};
            \node [StackBlock,label=above:$14$] (14) {};
            }


            { [continue chain = going above]
            \chainin (0);
            \node[StackBlock,yshift=2em,xshift=-0.5em,label=\texttt{head}] (head) {$0$};
            \draw[->] (head.south) [out=-90, in=90] to (0.north west);
            }

            { [continue chain = going right]
            \chainin (5);
            \node[StackBlock,yshift=0.5em,xshift=2em,label=above:\texttt{tail}] (tail) {$9$};
            \draw[->] (tail.west) [out=180, in=0] to (5.north east);
            }
            }
            %\begin{scope}[-{Stealth[length = 2.5pt]}]
            %\draw (1.north) [out=25, in=155] to (2.north);
            %\draw (1.north) [out=30, in=155] to (3.north);
            %\draw (1.north) [out=35, in=155] to (4.north);
            %\draw (6.north) [out=40, in=155] to (6.north);
            %\end{scope}
            %\draw[decorate,decoration={brace, amplitude=10pt, raise=5pt, mirror}]
            %(2.south west) to node[black,midway,below= 15pt] {$k$-elements} (7.south east);%

        \end{tikzpicture}
    \end{center}

    \textbf{Performance:} (dynamisch, bei unterliegender Datenstruktur Array)

    \begin{center}
        \begin{tabular}{c|c|c|c|c}
            Zugriff     & Suche       & Einf./Lösch. (Anfang)                                                                                   & Einf./Lösch. (Ende)                              & Einf./Lösch. (Mitte) \\
            \hline
            $\Theta(1)$ & $\Theta(n)$ & $\Theta(1)/\Theta(n)$\footnote{Wenn das Feld schon voll ist, muss der komplette Inhalt kopiert werden.} & $\Theta(1)/\Theta(n)$\footnote{Siehe Fußnote a.} & $\Theta(n)$          \\
        \end{tabular}
    \end{center}

    Damit ist ein zirkuläres (dynamisches) Feld gut für eine \emph{Queue/Deque} geeignet!
\end{defi}

\begin{bonus}{Prioritätswarteschlange}
    Eine \emph{Prioritätswarteschlange} ist eine Warteschlange, deren Elemente einen Schlüssel (\emph{Priorität}) besitzen.

    \textbf{Implementierung:}

    In Java dient zur Implementierung die Klasse \texttt{PriorityQueue}, alternativ auch \texttt{TreeSet}.
\end{bonus}

% Mengen
\begin{defi}{Menge}
    Eine \emph{Menge (Set)} ist eine Sammlung von Elementen des gleichen Datentyps.
    Innerhalb der Menge sind die Elemente ungeordnet.
    Jedes Element kann nur einmal in der Menge vorkommen.

    \textbf{Implementierung:}

    In Java ist \emph{Set} ein Interface, das unter anderem folgende Klassen implementiert:
    \begin{itemize}
        \item \texttt{TreeSet}: Basiert auf der Datenstruktur Rot-Schwarz-Baum, implementiert Erweiterung \texttt{SortedMap}.
        \item \texttt{HashSet}: Basiert auf der Datenstruktur Hashtabelle.
    \end{itemize}
\end{defi}

% Listen
\begin{defi}{Liste}
    Im Vergleich zu einem Array kann eine \emph{Liste} schrumpfen und wachsen.

    \begin{center}
        \begin{tikzpicture}[
                %  -{Stealth[length = 2.5pt]},
                start chain,
                node distance = 0pt,
                StackBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain},
            ]
            { start chain = going right
                \node [StackBlock, label=$0$] (0) {};
                \node [StackBlock, label=\texttt{next}] (0p) {};
                \node [StackBlock, label=$1$,xshift=2em] (1) {};
                \node [StackBlock, label=\texttt{next}] (1p) {};
                \node [StackBlock, label=$2$,xshift=2em] (2) {};
                \node [StackBlock, label=\texttt{next}] (2p) {};
                \node [StackBlock, label=$\ldots$,xshift=2em] (dots) {};
                \node [StackBlock] (dotsp) {};
                \node [StackBlock, label=$n$,xshift=2em] (n) {};
                \node [StackBlock, label=\texttt{next}] (np) {};
                \node [StackBlock, label=\texttt{null}, xshift=2em] (null) {};


                \draw[->] (0p.center) [out=0, in=180] to (1.west);
                \draw[->] (1p.center) [out=0, in=180] to (2.west);
                \draw[->] (2p.center) [out=0, in=180] to (dots.west);
                \draw[->] (dotsp.center) [out=0, in=180] to (n.west);
                \draw[->] (np.center) [out=0, in=180] to (null.west);
            }
        \end{tikzpicture}
    \end{center}

    \textbf{Performance:}

    \begin{center}
        \begin{tabular}{c|c|c|c|c}
            Zugriff     & Suche       & Einf./Lösch. (Anfang) & Einf./Lösch. (Ende)                                                                                 & Einf./Lösch. (Mitte)   \\
            \hline
            $\Theta(n)$ & $\Theta(n)$ & $\Theta(1)$           & $\Theta(1)/\Theta(n)$\footnote{$\Theta(1)$, wenn das letzte Element bekannt ist, $\Theta(n)$ sonst} & Suchzeit + $\Theta(1)$ \\
        \end{tabular}
    \end{center}
\end{defi}


\begin{defi}{Doppelt verkettete Liste}
    Im Vergleich zu einer einfach verketteten Liste besitzt die \emph{doppelt verkettete Liste} zusätzlich einen Verweis auf den Vorgänger.

    \begin{center}
        \begin{tikzpicture}[
                %  -{Stealth[length = 2.5pt]},
                start chain,
                node distance = 0pt,
                StackBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain},
            ]
            { start chain = going right
                \node [StackBlock,label=\texttt{null}] (nulll) {};

                \node [StackBlock,label={[label distance=-.35ex]above:\texttt{prev}}, xshift=2em] (0p) {};
                \node [StackBlock,label=$0$] (0) {};
                \node [StackBlock,label=\texttt{next}] (0n) {};
                \node [StackBlock,label={[label distance=-.35ex]above:\texttt{prev}},xshift=2em] (1p) {};
                \node [StackBlock,label=$1$] (1) {};
                \node [StackBlock,label=\texttt{next}] (1n) {};
                \node [StackBlock,xshift=2em] (dotsp) {};
                \node [StackBlock,label=$\ldots$] (dots) {};
                \node [StackBlock] (dotsn) {};
                \node [StackBlock,label={[label distance=-.35ex]above:\texttt{prev}},xshift=2em] (np) {};
                \node [StackBlock,label=$n$] (n) {};
                \node [StackBlock,label=\texttt{next}] (nn) {};

                \node [StackBlock,label=\texttt{null}, xshift=2em] (nullr) {};

                %\draw[->] ([yshift=0.5em, xshift=0.25em] 5.east) [out=0, in=180] to ([yshift=0.5em, xshift=-0.25em] 6.west);

                % next arrows
                \draw[->] ([yshift=0.5em] 0n.center) [out=0, in=180] to ([yshift=0.5em] 1p.west);
                \draw[->] ([yshift=0.5em] 1n.center) [out=0, in=180] to ([yshift=0.5em] dotsp.west);
                \draw[->] ([yshift=0.5em] dotsn.center) [out=0, in=180] to ([yshift=0.5em] np.west);

                \draw[->] (nn.center) [out=0, in=180] to (nullr.west);

                % prev arrows
                \draw[<-] ([yshift=-0.5em] 0n.east) [out=0, in=180] to ([yshift=-0.5em] 1p.center);
                \draw[<-] ([yshift=-0.5em] 1n.east) [out=0, in=180] to ([yshift=-0.5em] dotsp.center);
                \draw[<-] ([yshift=-0.5em] dotsn.east) [out=0, in=180] to ([yshift=-0.5em] np.center);

                \draw[->] (0p.center) [out=180, in=0] to (nulll.east);
            }
        \end{tikzpicture}
    \end{center}

    \textbf{Performance:}

    \begin{center}
        \begin{tabular}{c|c|c|c|c}
            Zugriff     & Suche       & Einf./Lösch. (Anfang) & Einf./Lösch. (Ende) & Einf./Lösch. (Mitte)   \\
            \hline
            $\Theta(n)$ & $\Theta(n)$ & $\Theta(1)$           & $\Theta(1)$         & Suchzeit + $\Theta(1)$ \\
        \end{tabular}
    \end{center}
\end{defi}

% Assoziative Felder
\begin{defi}{Assoziatives Feld}
    Ein \emph{assoziatives Feld} ist eine Sonderform des Feldes:
    \begin{itemize}
        \item Verwendet keinen numerischen Index zur Adressierung eines Elements.
        \item Verwendet zur Adressierung einen Schlüssel (z.B. \texttt{a["Meier"]}).
    \end{itemize}

    Assoziative Felder eignen sich dazu, Datenelemente in einer großen Datenmenge aufzufinden.
    Jedes Datenelement wird durch einen \emph{eindeutigen Schlüssel} identifiziert.

    \textbf{Implementierung:}

    In Java entspricht ein \emph{assoziatives Feld} dem Interface \texttt{java.util.Map}, das folgende Klassen implementiert:
    \begin{itemize}
        \item \texttt{TreeMap}: Basiert auf der Datenstruktur Rot-Schwarz-Baum, implementiert Erweiterung \texttt{SortedMap}.
        \item \texttt{HashMap}: Basiert auf der Datenstruktur Hashtabelle.
    \end{itemize}
\end{defi}

% Verkettete Listen

\subsection{Hashing}

% Hashtabellen

\begin{defi}{Hashfunktion}
    Eine Hashfunktion oder Streuwertfunktion ist eine Abbildung $h : S \to I$, die eine große Eingabemenge, die Schlüssel $S$, auf eine kleinere Zielmenge, die Hashwerte $I$, abbildet.\footnote{Eine Hashfunktion ist daher im Allgemeinen nicht injektiv, aber surjektiv.}

    Die Bildmenge $h(S) \subseteq I$ bezeichnet die Menge der \emph{Hash-Indizes}.


    \begin{center}
        \begin{tikzpicture}[
            %  -{Stealth[length = 2.5pt]},
            start chain = going {right=of \tikzchainprevious.north east},
            KeyBlock/.style={minimum width=4em, minimum height=2em, outer sep=0pt, on chain},
            HashBlock/.style={minimum width=2em, minimum height=2em, outer sep=0pt, on chain},
            FunctionBlock/.style={minimum width=10em, minimum height=26em, outer sep=0pt, on chain, very thick,fill=blue!20},
            every node/.style={draw, label distance=0.5em},
            every on chain/.style={anchor=north west},
            node distance=4em
            ]
            {
            \node [KeyBlock, label=above:Schlüssel] (k0) {Jürgen};
            \node [FunctionBlock, label=above:Hashfunktion] (fun) {};
            \node [HashBlock, label=above:Hashwerte] (h00) {00};

            { [continue chain = going {below=of \tikzchainprevious.south west}, node distance=2em]
            \chainin (k0);
            \node [KeyBlock] (k1) {Felix};
            \node [KeyBlock] (k2) {Finn};
            \node [KeyBlock] (k3) {Tim};
            \node [KeyBlock] (k4) {Benno};
            \node [KeyBlock] (k5) {Lukas};
            \node [KeyBlock] (k6) {Julia};
            }

            { [continue chain = going {below=of \tikzchainprevious.south west}, node distance=0pt]
            \chainin (h00);
            \node [HashBlock] (h01) {01};
            \node [HashBlock] (h02) {02};
            \node [HashBlock] (h03) {03};
            \node [HashBlock] (h04) {04};
            \node [HashBlock] (h05) {05};
            \node [HashBlock] (h06) {06};
            \node [HashBlock] (h07) {07};
            \node [HashBlock] (h08) {08};
            \node [HashBlock] (h09) {09};
            \node [HashBlock] (h10) {10};
            \node [HashBlock] (hdots) {$\ldots$};
            \node [HashBlock] (h15) {15};
            }

            \draw[->] (k0.east) -- ++(2, 0) -- ($(h05.west)-(2,0)$) -- (h05.west);
            \draw[->] (k1.east) -- ++(2, 0) -- ($(h09.west)-(2,0)$) -- (h09.west);
            \draw[->] (k2.east) -- ++(2, 0) -- ($(h00.west)-(2,0)$) -- (h00.west);
            \draw[->] (k3.east) -- ++(2, 0) -- ($(h15.west)-(2,0)$) -- (h15.west);
            \draw[->] (k4.east) -- ++(2, 0) -- ($(h02.west)-(2,0)$) -- (h02.west);
            \draw[->] (k5.east) -- ++(2, 0) -- ($(h10.west)-(2,0)$) -- (h10.west);
            \draw[->] (k6.east) -- ++(2, 0) -- ($(h03.west)-(2,0)$) -- (h03.west);
            }
        \end{tikzpicture}
    \end{center}
\end{defi}

\begin{example}{Divisions-Hash}
    Die \emph{Divisionsrest-Methode (Divisions-Hash)} um Integer zu hashen wird definiert durch:
    $$
        h(x) = x \operatorname{mod} N
    $$

    Sie wird bevorzugt, wenn die Schlüsselverteilung nicht bekannt ist.
    Etwaige Regelmäßigkeiten in der Schlüsselverteilung sollte sich nicht in der Adressverteilung auswirken. Daher sollte $N$ eine Primzahl sein.
\end{example}

\begin{example}{Hashfunktionen für verschiedene Datentypen}
    \begin{itemize}
        \item Alle Datenypen: Verwenden der Speicheradresse
        \item Strings: ASCII/Unicode-Werte addieren (evtl. von einigen Buchstaben, evtl. gewichtet)
    \end{itemize}
\end{example}

\begin{defi}{Kollision}
    Sei $S$ eine Schlüsselmenge und $h$ eine Hashfunktion.
    Ist
    $$
        s_1, s_2 \in S, \ s_1 \neq s_2 : h(s_1) = h(s_2)
    $$
    so spricht man von einer \emph{Kollision}.

    Die Wahrscheinlichkeit von Kollisionen ist abhängig von der gewählten Hashfunktion.
    Hashfunktionen sollten also möglichst gut \emph{streuen}, aber dennoch effizient berechenbar sein.

    \begin{center}
        \begin{tikzpicture}[
            %  -{Stealth[length = 2.5pt]},
            start chain = going {right=of \tikzchainprevious.north east},
            KeyBlock/.style={minimum width=4em, minimum height=2em, outer sep=0pt, on chain},
            HashBlock/.style={minimum width=2em, minimum height=2em, outer sep=0pt, on chain},
            FunctionBlock/.style={minimum width=10em, minimum height=26em, outer sep=0pt, on chain,fill=blue!20},
            every node/.style={draw, label distance=0.5em},
            every on chain/.style={anchor=north west},
            node distance=4em
            ]
            {
            \node [KeyBlock, label=above:Schlüssel, very thick] (k0) {Jürgen};
            \node [FunctionBlock, label=above:Hashfunktion] (fun) {};
            \node [HashBlock, label=above:Hashwerte] (h00) {00};

            { [continue chain = going {below=of \tikzchainprevious.south west}, node distance=2em]
            \chainin (k0);
            \node [KeyBlock] (k1) {Felix};
            \node [KeyBlock] (k2) {Finn};
            \node [KeyBlock] (k3) {Tim};
            \node [KeyBlock] (k4) {Benno};
            \node [KeyBlock] (k5) {Lukas};
            \node [KeyBlock, very thick] (k6) {Julia};
            }

            { [continue chain = going {below=of \tikzchainprevious.south west}, node distance=0pt]
            \chainin (h00);
            \node [HashBlock] (h01) {01};
            \node [HashBlock] (h02) {02};
            \node [HashBlock] (h03) {03};
            \node [HashBlock] (h04) {04};
            \node [HashBlock, very thick] (h05) {05};
            \node [HashBlock] (h06) {06};
            \node [HashBlock] (h07) {07};
            \node [HashBlock] (h08) {08};
            \node [HashBlock] (h09) {09};
            \node [HashBlock] (h10) {10};
            \node [HashBlock] (hdots) {$\ldots$};
            \node [HashBlock] (h15) {15};
            }

            \draw[->, very thick, color=red] (k0.east) -- ++(2, 0) -- ($(h05.west)-(2,0)$) -- (h05.west);
            \draw[->] (k1.east) -- ++(2, 0) -- ($(h09.west)-(2,0)$) -- (h09.west);
            \draw[->] (k2.east) -- ++(2, 0) -- ($(h00.west)-(2,0)$) -- (h00.west);
            \draw[->] (k3.east) -- ++(2, 0) -- ($(h15.west)-(2,0)$) -- (h15.west);
            \draw[->] (k4.east) -- ++(2, 0) -- ($(h02.west)-(2,0)$) -- (h02.west);
            \draw[->] (k5.east) -- ++(2, 0) -- ($(h10.west)-(2,0)$) -- (h10.west);
            \draw[->, very thick, color=red] (k6.east) -- ++(2, 0) -- ($(h05.west)-(2,0)$) -- (h05.west);
            }
        \end{tikzpicture}
    \end{center}

\end{defi}

\begin{defi}{Kollisionsbehandlung}
    Um Kollisionen zu handhaben, existieren verschiedene Strategien:
    \begin{itemize}
        \item \emph{Hashing mit Verkettung}
              \begin{itemize}
                  \item Hashtabelle besteht aus $N$ linearen Listen
                  \item $h(s)$ gibt dann an, in welche Teilliste der Datensatz gehört
                  \item Daten werden innerhalb der Teillisten sequentiell gespeichert
              \end{itemize}
        \item \emph{Hashing mit offener Adressierung}
              \begin{itemize}
                  \item Suchen einer alternativen Position innerhalb des Feldes
                        \begin{enumerate}
                            \item Lineares Sondieren (Verschiebung um konstantes Intervall)
                            \item Doppeltes Hashing (Intervall wird quadriert)
                            \item Quadratisches Sondieren (Nutzen einer weiteren Hashfunktion)
                        \end{enumerate}
              \end{itemize}
    \end{itemize}
\end{defi}

\begin{defi}{Schrittzahl}
    Die \emph{Schrittzahl} $S(s)$, die nötig ist, um den Datensatz mit Schlüssel $s$ zu speichern bzw. wiederzufinden, setzt sich z.B. beim Hashing mit Verkettung zusammen aus:
    \begin{itemize}
        \item der Berechnung der Hash-Funktion und
        \item dem Aufwand für die Suche bzw. Speicherung innerhalb der Teilliste.
    \end{itemize}
\end{defi}

\begin{defi}{Füllgrad}
    Der \emph{Füllgrad} einer Hashtabelle ist der Quotient
    $$
        \alpha = \frac{n}{N}
    $$
    mit
    \begin{itemize}
        \item $N$ als Größe der Hashtabelle
        \item $n$ als Anzahl der gespeicherten Datensätze
    \end{itemize}
\end{defi}

\begin{example}{Schrittzahl beim Suchen in Teillisten}
    Bei idealer Speicherung entfallen $\alpha$ Elemente auf jede Teilliste.
    Dabei gilt:
    \begin{itemize}
        \item erfolgreiche Suche: $c_1 + c_2 \cdot \frac{\alpha}{2}$
        \item erfolglose Suche: $c_1 + c_2 \cdot \alpha$
    \end{itemize}
    Damit ist der Suchaufwand in $\bigo(\alpha) = \bigo(\frac{n}{N})$.

    Wird der Füllgrad $\alpha$ zu groß, sollte die Hashtabelle vergrößert werden.
\end{example}

\begin{defi}{Dynamisches Hashing}
    Um viele Kollisionen zu vermeiden, muss die Hashtabelle ab einem gewissen Füllgrad vergrößert werden.\footnote{nach Sedgewick sollte stets $\alpha < 0.5$ gelten}

    Als Folge muss die gesamte Hashtabelle aber auch neu aufgebaut werden.
\end{defi}

\begin{defi}{Offene Adressierung (Sondieren)}
    Beim Speichern wird bei \emph{Hashing mit offener Adressieren (Sondierung)} so lang ein neuer Hashindex berechnet, bis dort ein freier Speicherplatz vorhanden ist.

    Das Suchen funktioniert analog, allerdings ist das Löschen sehr aufwändig.

    \begin{itemize}
        \item Lineares Sondieren
              \begin{itemize}
                  \item Wird die Ersatzadresse bei jeder Kollision durch Erhöhen der alten Adresse um 1 berechnet, so spricht man von \emph{linearem Sondieren (linear probing)}.
                  \item Die $i$-te Ersatzadresse für einen Schlüssel $s$ mit Hashindex $h(s)$ wird also wie folgt berechnet:
                        $$
                            h_i(s) = (h(s) + i) \operatorname{mod} N
                        $$
              \end{itemize}
        \item Doppeltes Hashing
              \begin{itemize}
                  \item Schlüssel wird nicht um $1$ erhöht, sondern der Inkrement wird mit einer zweiten Hashfunktion berechnet.
                  \item Beseitigt praktisch die Probleme der primären und sekundären Häufung.
                  \item Nicht alle Felder werden durchprobiert. Im ungünstigsten Fall kann eine neues Element nicht eingefügt werden, auch wenn noch Felder frei sind.
              \end{itemize}
    \end{itemize}
\end{defi}

\begin{defi}{Primäre und sekundäre Häufung}
    Bei der \emph{primären Häufung (primary clustering)} ist die Wahrscheinlichkeit, dass Plätze in einem dichtbelegten Bereich eher besetzt werden, deutlich höher.
    Es kommt also zu Kettenbildung.

    Besonders häufig tritt primäre Häufung z.B. beim linearen Sondieren auf.

    \begin{center}
        \begin{tikzpicture}
            [
                %  -{Stealth[length = 2.5pt]},
                start chain,
                node distance = 0pt,
                StackBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain},
            ]

            \node [draw, minimum width=2em, minimum height=2em] (val) {$s$};

            { start chain = going right
            \node [StackBlock,right=2cm of val,fill=red!30] (0) {};
            \node [StackBlock] (1) {};
            \node [StackBlock] (2) {};
            \node [StackBlock,fill=red!30] (3) {};
            \node [StackBlock,fill=red!30] (4) {};
            \node [StackBlock,fill=red!30] (5) {};
            \node [StackBlock,fill=red!30] (6) {};
            \node [StackBlock,fill=red!30] (7) {};
            \node [StackBlock] (8) {$s$};
            \node [StackBlock] (9) {};

            \draw[->] (val.south) [out=-30, in=-150] to (4.south);
            \draw[->] (4.south) [out=-45, in=-135] to (5.south);
            \draw[->] (5.south) [out=-45, in=-135] to (6.south);
            \draw[->] (6.south) [out=-45, in=-135] to (7.south);
            \draw[->] (7.south) [out=-45, in=-135] to (8.south);
            }
        \end{tikzpicture}
    \end{center}


    Die \emph{sekundäre Häufung (secondary clustering)} hängt von der Hashfunktion ab.
    Dabei durchlaufen zwei Schlüssel $h(s)$ und $h(s')$ stets dieselbe Sondierungsfolge.
    Sie behindern sich also auf den Ausweichplätzen.

    Besonders häufig tritt sekundäre Häufung z.B. beim quadratischen Sondieren auf.


    \begin{center}
        \begin{tikzpicture}
            [
                %  -{Stealth[length = 2.5pt]},
                start chain,
                node distance = 0pt,
                StackBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain},
            ]

            \node [minimum width=2em, minimum height=2em] (val) {};

            { start chain = going right
            \node [StackBlock,right=2cm of val] (0) {};
            \node [StackBlock,fill=red!30] (1) {};
            \node [StackBlock,fill=red!30] (2) {};
            \node [StackBlock,fill=red!30] (3) {};
            \node [StackBlock] (4) {};
            \node [StackBlock,fill=red!30] (5) {};
            \node [StackBlock] (6) {};
            \node [StackBlock] (7) {};
            \node [StackBlock] (8) {$s$};
            \node [StackBlock] (9) {$s'$};

            { [continue chain = going above]
            \chainin (val);
            \node [StackBlock] (val1) {$s$};
            }

            { [continue chain = going below]
            \chainin (val);
            \node [StackBlock] (val2) {$s'$};
            }

            \draw[->] (val1.east) [out=0, in=150] to (2.north);
            \draw[->] (2.north) [out=45, in=135] to (3.north);
            \draw[->] (3.north) [out=45, in=135] to (5.north);
            \draw[->] (5.north) [out=45, in=135] to (8.north);

            \draw[->] (val2.east) [out=0, in=-150] to (2.south);
            \draw[->] (2.south) [out=-45, in=-135] to (3.south);
            \draw[->] (3.south) [out=-45, in=-135] to (5.south);
            \draw[->] (5.south) [out=-45, in=-135] to (8.south);
            \draw[->] (8.south) [out=-45, in=-135] to (9.south);
            }
        \end{tikzpicture}
    \end{center}
\end{defi}

\section{Bäume}

\begin{defi}{Baum}
    Ein \emph{Baum} ist eine hierarchische (rekursive) Datenstruktur.
    Es gilt:
    \begin{itemize}
        \item alle Wege gehen von einer \emph{Wurzel} aus
        \item $A$ heißt \emph{Vorgänger} von $B$ bzw. $B$ \emph{Nachfolger} von $A$, wenn $A$ auf einem Weg von der Wurzel zu $B$ liegt
        \item $A$ heißt \emph{Elterknoten} von $B$, bzw. $B$ heißt \emph{Kind} von $A$, wenn $(A, B) \in E$
        \item Knoten ohne Kinder heißen \emph{Blätter}
        \item Knoten mit Kindern heißen \emph{innere Knoten}
        \item ein Knoten $S$ mit allen Nachfolgern wird \emph{Teilbaum} eines Baumes $T$ genannt, falls $S$ nicht Wurzel von $T$ ist
        \item der \emph{Verzweigungsgrad} eines Knotens ist die Anzahl seiner Kinder
    \end{itemize}

    \vspace{1em}

    \begin{center}
        \begin{forest}
            for tree={s sep=5mm, fit=band}
            [Wurzel, name=root
            [Blatt, name=blatt1]
            [Innerer Knoten, name=inner1 [Blatt, name=blatt2]
            [Innerer Knoten, name=inner2
            [Blatt, name=blatt3]
            [Innerer Knoten, name=inner3 [Blatt, name=blatt4]
            [Blatt, name=blatt5]]]]]
            \node [draw, label=left:Level 0, dashed, fit={(root) (blatt1.west |- root.center) (inner3.east |- root.center)}] {};
            \node [draw, label=left:Level 1, dashed, fit={(blatt1) (inner3.east |- blatt1.center)}] {};
            \node [draw, label=left:Level 2, dashed, fit={(blatt2) (blatt1.west |- blatt2.center) (inner3.east |- blatt2.center)}] {};
            \node [draw, label=left:Level 3, dashed, fit={(blatt3) (blatt1.west |- blatt3.center) (inner3)}] {};
            \node [draw, label=left:Level 4, dashed, fit={(blatt4) (blatt1.west |- blatt5.center) (blatt5) (inner3.east |- blatt5.center)}] {};
            \node [draw, red, fit={(inner2) (inner3) (blatt5) (blatt3)},label=right:{\color{red}Teilbaum}] {};
        \end{forest}
    \end{center}
\end{defi}

% Binärbäume

\begin{defi}{Binärbaum}
    Die Knoten eines \emph{Binärbaums (binary tree)} haben höchstens den Verzweigungsgrad $2$.

    Bei einem \emph{geordneten Binärbaum} ist die Reihenfolge der Kinder durch die Indizes eindeutig festgelegt:
    \begin{itemize}
        \item $T_l$: linkes Kind, linker Teilbaum
        \item $T_r$: rechtes Kind, rechter Teilbaum
    \end{itemize}

    Ein Binärbaum heißt \emph{minimal} (bezogen auf die Höhe), wenn kein Binärbaum mit gleicher Knotenzahl aber kleinerer Höhe existiert.

    Ein \emph{links-vollständiger Binärbaum} ist ein minimaler Binärbaum, in dem die Knoten auf dem untersten Level so weit wie möglich links stehen.

    Alle Blätter eines \emph{vollständigen Binärbaums} haben den gleichen Level.

    Ein vollständiger Binärbaum der Höhe $H$ hat
    $$
        n = 1 + 2 + 4 + \ldots + 2^H = \frac{2^{H+1}-1}{2-1} = 2^{H+1}-1 \ \text{Knoten}
    $$
\end{defi}

\begin{halfboxl}
    \begin{example}{Linksvollständiger Binärbaum}
        \centering
        \begin{forest}
            for tree={circle, draw,
            minimum size=1.75em, % <-- added
            inner sep=1pt}
            [
            [
                    [
                            []
                                []
                        ]
                        [
                            []
                                []
                        ]
                ]
                [
                    []
                        []
                ]
            ]
        \end{forest}
    \end{example}
\end{halfboxl}
\begin{halfboxr}
    \begin{example}{Vollständiger Binärbaum}
        \centering
        \begin{forest}
            for tree={circle, draw,
            minimum size=1.75em, % <-- added
            inner sep=1pt}
            [
            [
                    [
                            []
                                []
                        ]
                        [
                            []
                                []
                        ]
                ]
                [
                    [
                            []
                                []
                        ]
                        [
                            []
                                []
                        ]
                ]
            ]
        \end{forest}
    \end{example}
\end{halfboxr}

\subsection{Binäre Suchbäume}
% Binäre Suchbäume

\begin{defi}{Binärer Suchbaum}
    Ein \emph{binärer Suchbaum} ist ein Binärbaum, bei dem für jeden Knoten des Baumes gilt:

    Alle Schlüssel im linken Teilbaum sind kleiner, alle im rechten Teilbaum sind größer oder gleich dem Schlüssel in diesem Knoten.
\end{defi}

\begin{algo}{Suchen im binären Suchbaum}
    Suchen ist ohne Probleme durch einfaches Vergleichen ($<$ bzw. $\geq$) möglich.

    Suchen der $50$ in \textcolor{red}{rot} bzw. (erfolgloses) Suchen der $80$ in \textcolor{blue}{blau}.

    \vspace{1em}

    \centering
    \forestset{%
        empty node/.style={dashed}
    }
    \begin{forest}
        for tree={circle, draw,
        minimum size=2em, % <-- added
        inner sep=1pt}
        [60
        [
        20,edge={->,dashed,red,thick}
        [10 [,empty node][,empty node]]
        [30,edge={->,dashed,red,thick}
        [,empty node]
        [50,edge={->,dashed,red,thick}, draw=red [,empty node][,empty node]]
        ]
        ]
        [
        70,edge={->,dashed,blue,thick}
            [,empty node]
            [110,edge={->,dashed,blue,thick}
                    [90,edge={->,dashed,blue,thick}
                            [,empty node,edge={->,dashed,blue,thick},draw=blue][,empty node]
                    ]
                    [,empty node]
            ]
        ]
        ]
    \end{forest}
\end{algo}

\begin{algo}{Einfügen im binären Suchbaum}
    Ein Knoten kann ohne Probleme hinzugefügt werden, indem man solange sucht, bis man auf einen leeren Kindknoten trifft und dort einfügt.

    Einfügen der $40$ in \textcolor{red}{rot}.

    \vspace{1em}

    \centering
    \begin{forest}
        for tree={circle, draw,
        minimum size=2em, % <-- added
        inner sep=1pt}
        [60
            [
                20,edge={->,dashed,red,thick}
                    [10 [,empty node][,empty node]]
                    [30,edge={->,dashed,red,thick}
                            [,empty node]
                            [50,edge={->,dashed,red,thick} [
                                        40,edge={->,dashed,red,thick},draw=red
                                    ][,empty node]]
                    ]
            ]
            [
                70
                    [,empty node]
                    [110
                            [90
                                    [,empty node][,empty node]
                            ]
                            [,empty node]
                    ]
            ]
        ]
    \end{forest}
\end{algo}

\begin{algo}{Löschen im binären Suchbaum (Blatt)}
    Ein Blatt kann problemlos gelöscht werden.

    Löschen der $50$ in \textcolor{red}{rot}.

    \vspace{1em}

    \centering
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
        minimum size=2em, % <-- added
        inner sep=1pt}
        [20,edge={->,dashed,red,thick}
        [10
            [,empty node]
            [,empty node]
        ]
        [30,edge={->,dashed,red,thick}
        [,empty node]
        [50,edge={->,dashed,red,thick}, draw=red
        [,empty node]
        [,empty node]
        ]
        ]
        ]
    \end{forest}
    \hspace{5em}
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
            [20
                    [10
                            [,empty node]
                            [,empty node]
                    ]
                    [30
                            [,empty node]
                            [,empty node,draw=red]
                    ]
            ]
    \end{forest}
\end{algo}

\begin{algo}{Löschen im binären Suchbaum (Innerer Knoten mit einem Kind)}
    Soll ein innerer Knoten mit einem Kind gelöscht werden, rückt das Kind an die Stelle des Elterknotens.

    Löschen der $30$ in \textcolor{red}{rot}.

    \vspace{1em}

    \centering
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
        minimum size=2em, % <-- added
        inner sep=1pt}
        [20,edge={->,dashed,red,thick}
        [10
            [,empty node]
            [,empty node]
        ]
        [30,edge={->,dashed,red,thick}, draw=red
        [,empty node]
        [50,draw=blue
        [,empty node]
        [,empty node]
        ]
        {\draw[->,blue] () to[bend right=45] node[midway,above right,font=\small]{Vorrücken} (!u.east);}
        ]
        ]
    \end{forest}
    \hspace{5em}
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
        minimum size=2em, % <-- added
        inner sep=1pt}
        [20
        [10
            [,empty node]
            [,empty node]
        ]
        [50,draw=blue
        [,empty node]
        [,empty node]
        ]
        ]
    \end{forest}
\end{algo}

\begin{algo}{Löschen im binären Suchbaum (Innerer Knoten mit zwei Kindern)}
    Soll ein innerer Knoten mit zwei Kindern gelöscht werden, nimmt der nächstgrößere Knoten seinen Platz ein.

    Dieser wird wie folgt ermittelt (in \textcolor{purple}{lila}):
    \begin{enumerate}
        \item Gehe einen Schritt nach rechts.
        \item Gehe solange nach links, bis es kein linkes Kind mehr gibt.
    \end{enumerate}

    Löschen der $20$ in \textcolor{red}{rot}.

    \vspace{1em}

    \centering
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
        minimum size=2em, % <-- added
        inner sep=1pt}
        [20,draw=red
        [10
            [,empty node]
            [,empty node]
        ]
        [30,edge={->,dashed,purple,thick},draw=purple
        [,empty node,edge={->,dashed,purple,thick}]
        [50
            [,empty node]
            [,empty node]
        ]
        ]{\draw[->,blue] () to[bend right=45] node[midway,above right,font=\small]{Platz einnehmen} (!u.east);}
        ]
    \end{forest}
    %\hspace{1em}
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
        minimum size=2em, % <-- added
        inner sep=1pt}
        [30,draw=purple
        [10
            [,empty node]
            [,empty node]
        ]
        [,empty node
        %[,empty node]
        [50,draw=blue
        [,empty node]
        [,empty node]
        ]
        {\draw[->,blue] () to[bend right=45] node[midway,above right,font=\small]{Vorrücken} (!u.east);}
        ]
        ]
    \end{forest}
    %\hspace{1em}
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
        minimum size=2em, % <-- added
        inner sep=1pt}
        [30,draw=purple
        [10
            [,empty node]
            [,empty node]
        ]
        [50,draw=blue
        [,empty node]
        [,empty node]
        ]
        ]
    \end{forest}
\end{algo}

\begin{bonus}{Komplexität beim Suchen, Löschen und Einfügen in Binärbäumen}
    Die Komplexität der Funktionen Suchen, Löschen und Einfügen werden durch die Komplexität des Suchens eines Elements bestimmt.

    Im schlechtesten Fall ist die Anzahl der zu durchsuchenden Elemente gleich der Höhe des Baumes $+1$.
    Dabei hängt die Höhe stark von der Reihenfolge der Einfügeoperationen ab.

    \vspace{1em}

    \centering
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
            [10
                    [,empty node]
                    [
                        20
                            [,empty node]
                            [
                                30
                                    [,empty node]
                                    [
                                        40
                                            [,empty node]
                                            [
                                                50
                                                    [,empty node]
                                                    [
                                                        60
                                                            [,empty node]
                                                            [,empty node]
                                                    ]
                                            ]
                                    ]
                            ]
                    ]
            ]
    \end{forest}
    \hspace{5em}
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
            [
                40
                    [
                        20
                            [
                                10
                                    [,empty node]
                                    [,empty node]
                            ]
                            [
                                30
                                    [,empty node]
                                    [,empty node]
                            ]
                    ]
                    [
                        50
                            [,empty node]
                            [
                                60
                                    [,empty node]
                                    [,empty node]
                            ]
                    ]
            ]
    \end{forest}
\end{bonus}

% Balancierte Bäume

\begin{defi}{Balanciertheit}

    Ein Binärbaum mit $n$ Knoten hat im besten Fall (\emph{optimal balanciert}) die Höhe
    $$
        H = \lceil \log_2(n+1) \rceil - 1 = \lfloor \log_2(n) \rfloor
    $$
    Dabei ist Suchen in $\bigo(\log n)$.

    Ein Binärbaum mit $n$ Knoten hat im schlechtesten Fall (\emph{entartet/degeneriert}) die Höhe
    $$
        H = n-1
    $$
    Dabei ist Suchen in $\bigo(n)$.
\end{defi}

\begin{defi}{Balance-Kriterien}
    \begin{enumerate}
        \item Abgeschwächtes Kriterium für ausgeglichene Höhe
              \begin{itemize}
                  \item lokale Umordnungsoperationen reichen aus
                  \item z.B. \emph{AVL-Bäume} und Rot-Schwarz-Bäume
              \end{itemize}
        \item Jeder neue Knoten wandert an die Wurzel des Baumes
              \begin{itemize}
                  \item Vorteil: Zuletzt eingefügte Elemente lassen sich schneller finden
                  \item durch spezielles Einfügeverfahren wird Baum zusätzlich (teilweise) ausgeglichen
                  \item z.B. Splay-Bäume
              \end{itemize}
        \item Unausgeglichener Verzweigungsgrad ermöglicht ausgeglichene Höhe
              \begin{itemize}
                  \item z.B. \emph{B-Bäume}
              \end{itemize}
    \end{enumerate}
\end{defi}

\subsection{AVL-Bäume}

% AVL-Bäume

\begin{defi}{AVL-Baum}
    Bei einem \emph{AVL-Baum} unterscheiden sich die Höhen zweier Teilbäume des gleichen Knotens maximal um $1$.

    Der sogenannte \emph{Balance-Index} (oder Balance-Faktor) $\BF$ eines Knotens $T$ ist die Differenz
    $$
        \BF(T) := H(T_r) - H(T_l)
    $$
    Dabei gilt:
    \begin{itemize}
        \item Jeder Knoten hat einen Balance-Index.
        \item Er darf nur die Werte $-1$, $0$ oder $1$ annehmen.
    \end{itemize}

    %\vspace{2em}

    \centering
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
        minimum size=2em, % <-- added
        inner sep=1pt}
        [
        J, label=right:{\small\textcolor{blue}{+1}}
        [
        F, label=right:{\small\textcolor{blue}{-1}}
        [
        D, label=right:{\small\textcolor{blue}{-1}}
        [
        C, label=left:{\small\textcolor{blue}{0}}
        [,empty node]
        [,empty node]
        ]
        [,empty node]
        ]
        [
        G, label=right:{\small\textcolor{blue}{0}}
        [,empty node]
        [,empty node]
        ]
        ]
        [
        P, label=right:{\small\textcolor{blue}{+1}}
        [
        L, label=right:{\small\textcolor{blue}{+1}}
        [,empty node]
        [
        N, label=right:{\small\textcolor{blue}{0}}
        [,empty node]
        [,empty node]
        ]
        ]
        [
        V, label=right:{\small\textcolor{blue}{-1}}
        [
        S, label=right:{\small\textcolor{blue}{0}}
        [
        Q, label=right:{\small\textcolor{blue}{0}}
        [,empty node]
        [,empty node]
        ]
        [
        U, label=left:{\small\textcolor{blue}{0}}
        [,empty node]
        [,empty node]
        ]
        ]
        [
        X, label=right:{\small\textcolor{blue}{0}}
        [,empty node]
        [,empty node]
        ]
        ]
        ]
        ]
    \end{forest}
\end{defi}

\begin{algo}{Einfügen in einem AVL-Baum}
    Beim Einfügen in einen AVL-Baum wird zu Beginn analog zu einem regulären Binärbaum eingefügt.

    Anschließend wird sich der unmittelbare Elterknoten $E$ angeschaut und es gibt für den dortigen Balance-Index $\BF(E)$ drei Fälle:
    \begin{enumerate}
        \item $\BF(E)$ wird $0$:
              \begin{itemize}[-]
                  \item $\BF(E)$ war vorher $-1$
                  \item man kommt von einem Kindbaum, der vorher niedriger war
                  \item Höhe des Knotens ändert sich nicht
                  \item oberhalb bleiben alle Balance-Indizes gleich
                  \item $\implies$ AVL-Kriterium ist für den ganzen Baum erfüllt
              \end{itemize}
        \item $\BF(E)$ wird $\pm 1$:
              \begin{itemize}[-]
                  \item $\BF(E)$ war vorher $0$
                  \item Höhe des Teilbaums erhöht sich um $1$
                  \item $\implies$ Überprüfung der Balance-Indizes muss beim Elternknoten von $E$ fortgesetzt werden
              \end{itemize}
        \item $\BF(E)$ wird $\pm 2$:
              \begin{itemize}[-]
                  \item $\BF(E)$ war vorher $\pm 1$
                  \item $\implies$ Teilbaum muss \emph{rebalanciert} werden
              \end{itemize}
    \end{enumerate}
\end{algo}

\begin{algo}{Löschen in einem AVL-Baum}
    Beim Löschen in einen AVL-Baum wird zu Beginn analog zu einem regulären Binärbaum gelöscht.

    Anschließend wird sich der unmittelbare Elterknoten $E$ angeschaut und es gibt für den dortigen Balance-Index $\BF(E)$ drei Fälle:
    \begin{enumerate}
        \item $\BF(E)$ wird $\pm 1$:
              \begin{itemize}[-]
                  \item $\BF(E)$ war vorher $0$
                  \item Höhe des Knotens ändert sich nicht
                  \item oberhalb bleiben alle Balance-Indizes gleich
                  \item $\implies$ AVL-Kriterium ist für den ganzen Baum erfüllt
              \end{itemize}
        \item $\BF(E)$ wird $0$:
              \begin{itemize}[-]
                  \item $\BF(E)$ war vorher $0$
                  \item Höhe des Teilbaums verringert sich um $1$
                  \item $\implies$ Überprüfung der Balance-Indizes muss beim Elternknoten von $E$ fortgesetzt werden
              \end{itemize}
        \item $\BF(E)$ wird $\pm 2$:
              \begin{itemize}[-]
                  \item $\BF(E)$ war vorher $\pm 1$
                  \item $\implies$ Teilbaum muss \emph{rebalanciert} werden
              \end{itemize}
    \end{enumerate}
\end{algo}

\begin{algo}{Rebalancierung}
    Wenn bei einer Opeation ein Höhenunterschied von mehr als $1$ zwischen zwei Geschwister-Teilbäumen entsteht, ist beim Elterknoten das AVL-Kriterium verletzt.
    Eine entsprechende Korrektur heißt \emph{Rebalancierung}.
    Als Werkzeuge eignen sich hierfür die sogenannten \emph{Rotationen}.
\end{algo}

\begin{algo}{Einfachrotation}
    Wird ein AVL-Baum unbalanciert, wenn ein Knoten in den \emph{rechten Teilbaum des rechten Teilbaums} eingefügt wird (Rechts-Rechts-Situation), dann wird das durch eine \emph{Einfachrotation nach links} gelöst.

    Zuletzt wurde $9$ eingefügt. Linksrotation in \textcolor{purple}{lila}.

    \vspace{1em}

    \begin{center}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [3%, label=right:{\small\textcolor{red}{+2}}
            [1%, label=below right:{\small\textcolor{blue}{0}}
                [,empty node]
                [,empty node]
            ]
            [7, label=above:{\small\textcolor{red}{+2}}, draw=teal, name=7
            [,empty node]
            [8, label=right:{\small\textcolor{blue}{+1}}, draw=purple, edge={teal,thick}
            [,empty node, name=8c]
            [9, label=right:{\small\textcolor{blue}{0}}, edge={purple,thick},draw=purple
            ]
            ]
            {\draw[->,purple] () to[bend right=45] node[midway,above right,font=\small]{Linksrotation} (!u.east);}
            ]
            ]
            \draw[->,teal] (7) to[bend right=45] (8c);
        \end{forest}
        \hspace{5em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [3, label=right:{\small\textcolor{blue}{+1}}
            [1, label=right:{\small\textcolor{blue}{0}}
            [,empty node]
            [,empty node]
            ]
            [8, label=right:{\small\textcolor{blue}{0}}, draw=purple
            [7, label=right:{\small\textcolor{blue}{0}}, draw=teal, edge={teal,thick}
                [,empty node]
                [,empty node]
            ]
            [9, label=right:{\small\textcolor{blue}{0}}, edge={purple,thick},draw=purple
            [,empty node]
            [,empty node]
            ]
            ]
            ]
        \end{forest}
    \end{center}

    \vspace{1em}

    Wird ein AVL-Baum unbalanciert, wenn ein Knoten in den \emph{linken Teilbaum des linken Teilbaums} eingefügt wird (Links-Links-Situation), dann wird das durch eine \emph{Einfachrotation nach rechts} gelöst.

    Zuletzt wurde $1$ eingefügt. Rechtsrotation in \textcolor{purple}{lila}.

    \vspace{1em}

    \begin{center}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            7
            [
            3, label=above:{\small\textcolor{red}{-2}}, draw=teal, name=3
            [
            2, label=left:{\small\textcolor{blue}{-1}}, draw=purple, edge={teal,thick},draw=purple
            [
            1, label=left:{\small\textcolor{blue}{0}}, draw=purple, edge={purple,thick},draw=purple
            ]
            [,empty node, name=2c]
            ]
            {\draw[->,purple] () to[bend left=45] node[midway,above left,font=\small]{Rechtsrotation} (!u.west);}
            [,empty node]
            ]
            [
            8
                [,empty node]
                [,empty node]
            ]
            ]
            \draw[->,teal] (3) to[bend left=45] (2c);
        \end{forest}
        \hspace{5em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            7, label=left:{\small\textcolor{blue}{-1}}
            [
            2, label=left:{\small\textcolor{blue}{0}}, draw=purple,draw=purple
            [
            1, label=left:{\small\textcolor{blue}{0}}, draw=purple, edge={purple,thick},draw=purple
            [,empty node]
            [,empty node]
            ]
            [3, label=left:{\small\textcolor{blue}{0}}, draw=teal, name=3, edge={teal,thick}
                [,empty node]
                [,empty node]
            ]
            ]
            [
            8, label=left:{\small\textcolor{blue}{0}}
            [,empty node]
            [,empty node]
            ]
            ]
        \end{forest}
    \end{center}
\end{algo}

\begin{algo}{Doppelrotation}
    Wird ein AVL-Baum unbalanciert, wenn ein Knoten in den \emph{rechten Teilbaum des linken Teilbaums} eingefügt wird, dann wird das durch eine \emph{Doppelrotation} (Linksrotation, gefolgt von Rechtsrotation) gelöst.

    Zuletzt wurde $4$ eingefügt. Rotationen in \textcolor{purple}{lila}.

    \vspace{1em}

    \begin{center}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            7, label=left:{\small\textcolor{red}{-2}}
            [
            3, label=left:{\small\textcolor{blue}{+1}}, draw=teal, name=3
            [,empty node]
            [4, draw=purple, label=right:{\small\textcolor{blue}{0}}, edge={teal,thick},draw=purple
            [,empty node, draw=none, edge={draw=none}, name=4c]
            [,empty node, draw=none, edge={draw=none}]
            ]
            {\draw[->,purple] () to[bend right=45] node[midway,above right,font=\small]{Linksrotation} (!u.east);}
            ]
            [,empty node]
            ]
            \draw[->,teal] (3) to[bend right=45] (4c);
        \end{forest}
        \hspace{-2em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            7, draw=teal, name=7, label=right:{\small\textcolor{red}{-2}}
            [
            4, draw=purple, edge={teal,thick}, label=left:{\small\textcolor{blue}{-1}}
            [
            3, draw=purple, edge={purple,thick}, label=left:{\small\textcolor{blue}{0}}
            [,empty node]
            [,empty node]
            ]
            [,empty node, name=4c]
            ]
            {\draw[->,purple] () to[bend left=45] node[midway,above left,font=\small]{Rechtsrotation} (!u.west);}
            [,empty node]
            ]
            \draw[->,teal] (7) to[bend left=45] (4c);
        \end{forest}
        \hspace{3em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            4, draw=purple, label=right:{\small\textcolor{blue}{0}}
            [
            3, draw=purple, edge={purple,thick}, label=right:{\small\textcolor{blue}{0}}
            [,empty node]
            [,empty node]
            ]
            [
            7, draw=teal, edge={teal,thick}, label=right:{\small\textcolor{blue}{0}}
            [,empty node]
            [,empty node]
            ]
            ]
        \end{forest}
    \end{center}

    \vspace{1em}

    Wird ein AVL-Baum unbalanciert, wenn ein Knoten in den \emph{linken Teilbaum des rechten Teilbaums} eingefügt wird, dann wird das durch eine \emph{Doppelrotation} (Rechtsrotation, gefolgt von Linksrotation) gelöst.

    Zuletzt wurde $3$ eingefügt. Rotationen in \textcolor{purple}{lila}.

    \vspace{1em}

    \begin{center}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            2, label=right:{\small\textcolor{red}{+2}}
            [,empty node]
            [
            5, label=right:{\small\textcolor{blue}{-1}}, draw=teal, name=5
            [3, draw=purple, label=left:{\small\textcolor{blue}{0}}, edge={teal,thick},draw=purple
            [,empty node, draw=none, edge={draw=none}]
            [,empty node, draw=none, edge={draw=none}, name=3c]
            ]
            {\draw[->,purple] () to[bend left=45] node[midway,above left,font=\small]{Rechtsrotation} (!u.west);}
            [,empty node]
            ]
            ]
            \draw[->,teal] (5) to[bend left=45] (3c);
        \end{forest}
        \hspace{5em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            2, label=left:{\small\textcolor{red}{+2}}, draw=teal, name=2
            [,empty node]
            [
            3, label=right:{\small\textcolor{blue}{+1}}, draw=purple, edge={teal,thick}
            [,empty node, name=3c]
            [5, draw=purple, label=right:{\small\textcolor{blue}{0}}, edge={purple,thick},draw=purple
            [,empty node]
            [,empty node]
            ]
            ]
            {\draw[->,purple] () to[bend right=45] node[midway,above right,font=\small]{Linksrotation} (!u.east);}
            ]
            \draw[->,teal] (2) to[bend right=45] (3c);
        \end{forest}
        \hspace{1em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            3, label=right:{\small\textcolor{blue}{0}},draw=purple
            [
            2, label=right:{\small\textcolor{blue}{0}}, edge={teal,thick},draw=teal
            [,empty node]
            [,empty node]
            ]
            [
            5, label=right:{\small\textcolor{blue}{0}}, edge={purple,thick},draw=purple
            [,empty node]
            [,empty node]
            ]
            ]
        \end{forest}
    \end{center}
\end{algo}


\begin{defi}{Komplexität von AVL-Bäumen}
    \begin{itemize}
        \item Einfügen
              \begin{itemize}
                  \item Element muss gesucht werden: $\bigo(\log n)$
                  \item Element muss angehängt werden: $\bigo(1)$
                  \item Baum muss ausgeglichen werden: $\bigo(\log n)$
              \end{itemize}
        \item Löschen
              \begin{itemize}
                  \item Element muss gesucht werden: $\bigo(\log n)$
                  \item nächstgrößeres Element muss gesucht werden: $\bigo(\log n)$
                  \item Elemente müssen verschoben werden: $\bigo(1)$
                  \item Baum muss ausgeglichen werden: $\bigo(\log n)$
              \end{itemize}
        \item Prüfen/Auslesen
              \begin{itemize}
                  \item Element muss gesucht werden: $\bigo(\log n)$
              \end{itemize}
    \end{itemize}
\end{defi}

\subsection{B-Bäume}
% B-Bäume

\begin{defi}{B-Baum}
    Jeder Knoten in einem \emph{B-Baum der Ordnung d} enthält $d$ bis $2d$ Elemente.

    Die Wurzel bildet die einzige Ausnahme, sie kann $1$ bis $2d$ Elemente enthalten.

    Die Elemente in einem Knoten sind aufsteigend sortiert.

    Die Anzahl der Kinder in einem B-Baum ist entweder $0$ (Blatt) oder um eins größer als die Anzahl der Elemente, die der Knoten enthält.

    Alle Blätter liegen auf demselben Level.
    \begin{itemize}[-]
        \item garantierte Zugriffszeiten
        \item bei realistischen Parametern (z.B. Ordnung $1000$) sind sehr wenige ($<5$) Zugriffe auf das externe Medium nötig
    \end{itemize}

    B-Bäume besitzen ausgeglichene Höhe, lassen aber unausgeglichenen Verzweigungsgrad und Knotenfüllgrad zu.

    Der längste Weg in einem B-Baum der Ordnung $d$ ist in $\bigo(\log_{d+1} n)$.

    B-Baum der Ordnung $2$:
    \vspace{1em}

    \centering
    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=2em,
        }
        [{\mpnc{\textcolor{red}{30}}{\textcolor{violet}{38}}{\textcolor{blue}{42}}{\times}}
            [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                        \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
                    }]
            [{\mpnc{32}{34}{35}{\times}}, name=c2, edge path={
                        \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
                    }]
            [{\mpnc{40}{41}{\times}{\times}}, name=c3, edge path={
                        \noexpand\path [draw, \forestoption{edge}] (!u.parent anchor) -- (.child anchor)\forestoption{edge label};
                    }]
            [{\mpnc{44}{50}{56}{58}}, name=c4, edge path={
                        \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
                    }]
        ]
        \node[fit=(c1), label=below:{$\in [-\infty, \text{\textcolor{red}{30}}]$}] {};
        \node[fit=(c2), label=below:{$\in [\text{\textcolor{red}{30}}, \text{\textcolor{purple}{38}}]$}] {};
        \node[fit=(c3), label=below:{$\in [\text{\textcolor{purple}{38}}, \text{\textcolor{blue}{42}}]$}] {};
        \node[fit=(c4), label=below:{$\in [\text{\textcolor{blue}{42}}, \infty]$}] {};
    \end{forest}
\end{defi}

\begin{algo}{Suchen in einem B-Baum}
    Ausgehend von der Wurzel:
    \begin{enumerate}
        \item Prüfe, ob der gerade betrachtete Knoten den gesuchten Schlüssel $m$ enthält.
              \subitem (Suche innerhalb eines Knotens entweder linear oder binär.)
        \item Falls nicht, bestimme den kleinsten Schlüssel $k_i$, der größer als $m$ ist.
              \begin{itemize}
                  \item $k_i$ gefunden: Weiter bei Schritt 1 mit linkem Kind von $k_i$ ($p_{i-1}$)
                  \item $k_i$ nicht gefunden: Weiter mit letztem Kind ($p_{n}$)
              \end{itemize}
    \end{enumerate}
\end{algo}

\begin{algo}{Einfügen in einem B-Baum der Ordnung $d$}
    \begin{enumerate}
        \item Suche nach Schlüssel endet in einem Blatt \texttt{node} (in \textcolor{purple}{lila})
        \item Schlüssel wird in Sortierreihenfolge eingefügt (und neuer leerer Verweis eingefügt)
        \item Falls \texttt{node} überfüllt ist: \texttt{node} aufteilen
              \subitem $k$ sei mittlerer Eintrag von \texttt{node}
              \begin{enumerate}
                  \item Neuen Knoten \texttt{current} anlegen und mit den $d$ größeren Schlüsseln (rechts von $k$) belegen.
                  \item Die $d$ kleineren Schlüssel (links von $k$) bleiben in \texttt{node}.
                  \item $k$ in Elterknoten \texttt{parent} von \texttt{node} verschieben.
                  \item Verweis rechts von $k$ in \texttt{parent} mit \texttt{current} verbinden.
              \end{enumerate}
        \item Falls \texttt{parent} nun überfüllt ist: \texttt{parent} aufteilen (Siehe Schritt 3)
    \end{enumerate}

    Einfügen der 60 in \textcolor{red}{rot}.

    \vspace{1em}

    \centering
    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{38}{42}{\times}}
            [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                        \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
                    }]
            [{\mpnc{32}{34}{35}{\times}}, name=c2, edge path={
                        \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
                    }]
            [{\mpnc{40}{41}{\times}{\times}}, name=c3, edge path={
                        \noexpand\path [draw, \forestoption{edge}] (!u.parent anchor) -- (.child anchor)\forestoption{edge label};
                    }]
            [{\mpnc{44}{50}{56}{58}}, name=c4, edge={dashed,purple,thick}, draw=purple, edge path={
                        \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
                    }]
        ]
        \node[draw, above of=c4, rectangle, red, node distance=5em] (60) {60};
        \draw[->, red] (60) to (c4);
    \end{forest}

    \vspace{1em}

    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{38}{42}{\times}}, name=r
        [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{32}{34}{35}{\times}}, name=c2, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{40}{41}{\times}{\times}}, name=c3]
        [{\mpnc{44}{50}{\times}{\times}}, name=c4, draw=red, edge={draw=none}]
        [{\mpnc{58}{\textcolor{red}{60}}{\times}{\times}}, name=c5, draw=red, edge={draw=none}]
        ]
        \node[draw, above right of=c4, rectangle, blue, node distance=sqrt(2)*4em] (56) {56};
        \draw[->, blue, bend right=15] (56) to (r);
    \end{forest}

    \vspace{1em}

    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{38}{42}{\textcolor{blue}{56}}}, name=r
        [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{32}{34}{35}{\times}}, name=c2, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{40}{41}{\times}{\times}}, name=c3]
        [{\mpnc{44}{50}{\times}{\times}}, name=c4, draw=red, edge={red}, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{58}{\textcolor{red}{60}}{\times}{\times}}, name=c5, draw=red, edge={red}, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        ]
    \end{forest}
\end{algo}

\begin{algo}{Löschen in einem B-Baum der Ordnung $d$ (Blatt)}
    In einem Blatt mit Struktur
    \begin{center}
        \texttt{(null, $k_1$, null, $\ldots$, $k_i$, null, $\ldots$, $k_n$, null)}
    \end{center}
    (\texttt{null} sind hier die Kinder an der jeweiligen Stelle)
    wird der Wert $x = k_i$ zusammen mit der darauf folgenden \texttt{null}-Referenz gelöscht.

    Ein \emph{Underflow} tritt auf, falls $n=d$ war.
\end{algo}

\begin{algo}{Löschen in einem B-Baum der Ordnung $d$ (Innerer Knoten)}
    In einem inneren Knoten mit Struktur

    \begin{center}
        \texttt{($p_0$, $k_1$, $p_1$, $\ldots$, $k_i$, $p_i$, $\ldots$, $k_n$, $p_n$)}
    \end{center}

    ($p_j$ sind hier die Kinder an der jeweiligen Stelle)
    haben alle Referenzen einen Wert ungleich \texttt{null}.

    Das Löschen eines Wertes $x = k_i$ funktioniert analog zum Löschen aus einem binären Suchbaum:
    \begin{enumerate}
        \item Finde kleinsten Schlüssel $s$ im durch $p_i$ referenzierten Teilbaum (in einem Blatt)
        \item Ersetze $k_i$ durch $s$ und lösche $s$ aus dem Blatt
    \end{enumerate}

    Löschen der 38 in \textcolor{red}{rot}.

    \centering
    \vspace{1em}

    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{\textcolor{red}{38}}{42}{56}}, name=r
        [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{32}{34}{35}{\times}}, name=c2, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{40}{41}{\times}{\times}}, name=c3]
        [{\mpnc{44}{50}{\times}{\times}}, name=c4, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{58}{60}{\times}{\times}}, name=c5, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        ]
    \end{forest}

    \vspace{1em}

    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{\phantom{38}}{42}{56}}, name=r
        [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{32}{34}{35}{\times}}, name=c2, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{\textcolor{blue}{40}}{41}{\times}{\times}}, name=c3]
        [{\mpnc{44}{50}{\times}{\times}}, name=c4, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{58}{60}{\times}{\times}}, name=c5, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        ]
        \draw[->, blue] ([xshift=-2.55em] c3.north) to[bend left=15] ([xshift=-0.75em]r.south);
    \end{forest}

    \vspace{1em}

    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{\textcolor{blue}{40}}{42}{56}}, name=r
        [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{32}{34}{35}{\times}}, name=c2, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{41}{\times}{\times}{\times}}, name=c3, draw=purple, label=below:\textcolor{purple}{Underflow!}]
        [{\mpnc{44}{50}{\times}{\times}}, name=c4, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{58}{60}{\times}{\times}}, name=c5, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        ]
    \end{forest}
\end{algo}

\begin{defi}{Underflow}
    Ein \emph{Underflow} tritt in einem B-Baum genau dann auf, wenn zu wenig ($<d$) Schlüssel im Knoten sind.
\end{defi}

\begin{algo}{Ausgleich zwischen Geschwisterknoten}
    Voraussetzung: Knoten $q$ mit Underflow hat einen Geschwisterknoten $p$ mit $>d$ Schlüsseln.

    Annahme:
    \begin{itemize}
        \item $p$ ist linker Geschwisterknoten von $q$ (analog mit rechtem Geschwisterknoten)
        \item im Elterknoten \texttt{parent} (von $p$ und $q$) trennt der Schlüssel $t$ die Verweise auf $p$ und $q$
    \end{itemize}

    Idee: $p$ schenkt $q$ ein Element (\glqq Umweg\grqq über Elterknoten)

    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{\textcolor{blue}{40}}{42}{56}}, name=r
        [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{32}{34}{\textcolor{blue}{35}}{\times}}, name=c2, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{41}{\times}{\times}{\times}}, name=c3, draw=purple]
        [{\mpnc{44}{50}{\times}{\times}}, name=c4, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{58}{60}{\times}{\times}}, name=c5, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        ]
        \draw[->, blue] ([xshift=0.75em] c2.north) to[bend left=90] ([xshift=2.25em] r.north west);
        \draw[<-, blue] ([xshift=-3.4em] c3.north) to[bend right=10] ([xshift=-0.75em] r.south);
    \end{forest}

    \vspace{1em}

    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{\textcolor{blue}{35}}{42}{56}}, name=r
        [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{32}{34}{\times}{\times}}, name=c2, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{\textcolor{blue}{40}}{41}{\times}{\times}}, name=c3]
        [{\mpnc{44}{50}{\times}{\times}}, name=c4, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{58}{60}{\times}{\times}}, name=c5, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        ]
    \end{forest}
\end{algo}

\begin{algo}{Verschmelzen von Geschwisterknoten}
    Voraussetzung: Knoten $q$ hat Geschwisterknoten mit $d$ Schlüsseln

    Annahme:
    \begin{itemize}
        \item $p$ ist linker Geschwisterknoten von $q$ (analog mit rechtem Geschwisterknoten)
        \item im Elterknoten \texttt{parent} (von $p$ und $q$) trennt der Schlüssel $t$ die Verweise auf $p$ und $q$
    \end{itemize}

    Idee: $p$ und $q$ mit dem trennenden Element aus \texttt{parent} verschmelzen.

    Beachte:
    \begin{itemize}
        \item Eventueller Underflow in \texttt{parent} muss behandelt werden (rekursiv)
        \item Falls letzter Schlüssel der Wurzel gelöscht wird, wird der einzige Nachfolger der Wurzel die neue Wurzel (Höhe des B-Baums wird um 1 verringert).
    \end{itemize}

    \vspace{1em}

    \centering
    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{40}{\textcolor{blue}{42}}{56}}, name=r
        [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{32}{34}{35}{\times}}, name=c2, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{41}{\times}{\times}{\times}}, name=c3, draw=purple]
        [{\mpnc{44}{50}{\times}{\times}}, name=c4, draw=blue, edge={blue}, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{58}{60}{\times}{\times}}, name=c5, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        ]
        \draw[<-, blue] ([xshift=-0.75em] c3.north) to[bend left=10] ([xshift=0.75em] r.south);
        \draw[<-, blue] ([xshift=0.75em] c3.north) to[bend left=45] ([xshift=-3.4em] c4.north);
    \end{forest}

    \vspace{1em}

    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{40}{56}{\times}}, name=r
        [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{32}{34}{35}{\times}}, name=c2, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{41}{\textcolor{blue}{42}}{\textcolor{blue}{44}}{\textcolor{blue}{50}}}, name=c3]
        [{\mpnc{58}{60}{\times}{\times}}, name=c5, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        ]
    \end{forest}
\end{algo}

\begin{defi}{B+-Baum}
    Im Unterschied zu B-Bäumen speichern \emph{B+-Bäume} ihre Datensätze ausschließlich in den Blättern.

    Dies ist bei der Anwendung für Datenbanken naheliegend und sinnvoll.
\end{defi}

\subsection{Rot-Schwarz-Bäume}

\begin{defi}{Rot-Schwarz-Baum}
    Ein \emph{Rot-Schwarz-Baum} ist ein balancierter binärer Suchbaum, in dem jeder innere Knoten zwei Kinder hat.

    Jeder innere Knoten hat eine Farbe, so dass gilt:
    \begin{itemize}
        \item Die Wurzel ist schwarz.
        \item Alle Blätter (\text{null}-Knoten) sind schwarz.
        \item Für jeden Knoten gilt, dass jeder Pfad zu den Blättern die gleiche Anzahl an schwarzen Knoten hat. (Schwarz-Tiefe)
        \item Beide Kinder eines roten Knotens sind schwarz.
    \end{itemize}
\end{defi}

\begin{algo}{Einfügen in einen Rot-Schwarz-Baum}
    Zuerst wird wie in einem normalen Binärbaum eingefügt, danach werden die Rot-Schwarz-Bedingungen repariert.

    Annahmen:
    \begin{itemize}
        \item eingefügter Knoten $v$ ist rot
        \item Elterknoten $u$ von $v$ ist rot (sonst fertig)
        \item $v$ ist linkes Kind von $u$ (anderer Fall symmetrisch)
        \item Geschwisterknoten $w$ (rechtes Kind von $u$) ist schwarz
        \item Alle roten Knoten außer $u$ haben 2 schwarze Kinder
    \end{itemize}


    \begin{center}

        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    p, b
                        [
                            u, r
                                [
                                    v, r
                                ]
                                [
                                    w, b, name=w
                                ]
                        ]
                        [
                            q, rbn
                        ]
                ]
        \end{forest}
        \hspace{7em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    p, b
                        [
                            q, rbn
                        ]
                        [
                            u, r
                                [
                                    v, r
                                ]
                                [
                                    w, b, name=w
                                ]
                        ]
                ]
        \end{forest}
    \end{center}
\end{algo}

\begin{algo}{Einfügen in einen Rot-Schwarz-Baum (Fall 1)}

    \textbf{Fall 1: Onkelknoten $q$ von $v$ ist schwarz}\\
    Fall 1a: $u$ ist linkes Kind von $p$ ($v$-$u$-$p$ bilden eine Linie)
    \vspace{1em}

    \begin{center}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    p, b
                        [
                            u, r
                                [
                                    v, r
                                ]
                                [
                                    w, b, name=w
                                ]
                            %{\draw[->,blue, dashed] () to[bend left=30] (!u.south);}
                        ]
                        {\draw[->,blue] () to[bend left=45] node[midway,above left,font=\small]{Rechtsrotation} (!u.west);}
                        [
                            q, b
                        ]
                ]
            %{\draw[->,blue, dashed] () to[bend left=45] (w.north east);}
        \end{forest}
        \hspace{3em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    u, r
                        [
                            v, r
                        ]
                        [
                            p, b
                                [
                                    w, b
                                ]
                                [
                                    q, b
                                ]
                        ]
                        {\draw[<->,blue] () to[bend right=45] node[midway,above right,font=\small]{Umfärben} (!u.east);}
                ]
            %{\draw[->,blue, dashed] () to[bend left=45] (w.north east);}
        \end{forest}
        \hspace{1em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    u, b
                        [
                            v, r
                        ]
                        [
                            p, r
                                [
                                    w, b
                                ]
                                [
                                    q, b
                                ]
                        ]
                    %{\draw[<->,blue] () to[bend right=45] node[midway,above right,font=\small]{Umfärben} (!u.east);}
                ]
            %{\draw[->,blue, dashed] () to[bend left=45] (w.north east);}
        \end{forest}
    \end{center}

    \vspace{1em}
    Fall 1b: $u$ ist rechtes Kind von $p$ ($v$-$u$-$p$ bilden ein Dreieck)

    \begin{center}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    p, b
                        [
                            q, b
                        ]
                        [
                            u, r
                                [
                                    v, r
                                ]
                                {\draw[->,blue] () to[bend left=45] node[midway,below left=1em,font=\small]{Rechtsrotation} (!u.west);}
                                [
                                    w, b, name=w
                                ]
                            %{\draw[->,blue, dashed] () to[bend left=30] (!u.south);}
                        ]
                ]
            %{\draw[->,blue, dashed] () to[bend left=45] (w.north east);}
        \end{forest}
        \hspace{5em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    p, b
                        [
                            q, b
                        ]
                        [
                            v, r
                                [,nil]
                                [
                                    u, r
                                        [,nil]
                                        [
                                            w, b
                                        ]
                                ]
                        ]
                        {\draw[->,blue] () to[bend right=45] node[midway,above right,font=\small]{Linksrotation} (!u.east);}
                ]
        \end{forest}

        \vspace{1em}

        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    v, r
                        [
                            p, b
                                [
                                    q, b
                                ]
                                [, nil]
                        ]
                        {\draw[<->,blue] () to[bend left=45] node[midway,above left,font=\small]{Umfärben} (!u.west);}
                        [
                            u, r
                                [, nil]
                                [
                                    w, b
                                ]
                        ]
                ]
        \end{forest}
        \hspace{2em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    v, b
                        [
                            p, r
                                [
                                    q, b
                                ]
                                [, nil]
                        ]
                        [
                            u, r
                                [, nil]
                                [
                                    w, b
                                ]
                        ]
                ]
        \end{forest}
    \end{center}
\end{algo}

\begin{algo}{Einfügen in einen Rot-Schwarz-Baum (Fall 2)}
    \textbf{Fall 2: Geschwisterknoten $q$ von $u$ ist rot}

    \begin{center}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            p, b, name=p
            [
            u, r, name=u
            [
            v, r
            ]
            [
            w, b, name=w
            ]
            ]
            [
            q, r, name=q
            ]
            ]
            \node [draw, fit={(p)(u)(q)}, blue, label=above:\textcolor{blue}{Umfärben}] () {};
        \end{forest}
        \hspace{7em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    p, r
                        [
                            u, b
                                [
                                    v, r
                                ]
                                [
                                    w, b, name=w
                                ]
                        ]
                        [
                            q, b
                        ]
                ]
        \end{forest}
    \end{center}

    \vspace{1em}

    beziehungsweise

    \vspace{1em}

    \begin{center}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            p, b, name=p
            [
            q, r, name=q
            ]
            [
            u, r, name=u
            [
            v, r
            ]
            [
            w, b, name=w
            ]
            ]
            ]
            \node [draw, fit={(p)(u)(q)}, blue, label=above:\textcolor{blue}{Umfärben}] () {};
        \end{forest}
        \hspace{7em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    p, r
                        [
                            q, b
                        ]
                        [
                            u, b
                                [
                                    v, r
                                ]
                                [
                                    w, b, name=w
                                ]
                        ]
                ]
        \end{forest}
    \end{center}

    \vspace{1em}

    \begin{itemize}
        \item Falls der Elterknoten von $p$ schwarz ist, sind wir fertig
        \item Falls $p$ die Wurzel ist, färbe $p$ schwarz
        \item Sonst behandle $p$ wie $v$ und wiederhole
    \end{itemize}
\end{algo}

\begin{algo}{Löschen in einem Rot-Schwarz-Baum}
    Das Löschen in einem Rot-Schwarz-Baum kann schnell sehr schwierig zu visualisieren werden.

    Ich will hier gern einmal folgende Videos empfehlen:
    \begin{itemize}
        \item \url{https://youtu.be/eO3GzpCCUSg} (ausführliche Beispiele, englisch)
        \item \url{https://youtu.be/bDT1woMULVw} (ausführliche Erklärung, Pseudocode, deutsch)
    \end{itemize}
\end{algo}

\subsection{Heaps}

\begin{bonus}{Heap (Wortbedeutungen)}
    Das Wort \emph{Heap} hat zwei Bedeutungen:
    \begin{itemize}
        \item Besonderer Speicherbereich, in dem Objekte und Klassen gespeichert werden.
        \item Datenstruktur zur effizienten Implementierung einer Prioritätswarteschlange.
    \end{itemize}
\end{bonus}

\begin{defi}{Heap}
    Ein \emph{Heap} ist ein Binärbaum mit folgenden Eigenschaften:
    \begin{itemize}
        \item linksvollständig
        \item Kinder eines Knotens höchstens so groß wie der Knoten selbst (Max-Heap)
        \item größtes Element befindet sich an der Wurzel (Max-Heap)
        \item entlang jedes Pfades von einem Knoten zur Wurzel sind Knoteninhalte aufsteigend sortiert
    \end{itemize}
\end{defi}

\begin{algo}{Einfügen in einem Heap}
    Das Einfügen eines Elements in den Heap erfolgt, indem das neue Element an das Ende des Heaps gesetzt wird.

    Weil das neu eingesetzte Element  die Eigenschaften des Heaps verzerren kann, wird die Operation \emph{Up-Heapify} durchgeführt, um die Eigenschaften des Heaps in einem Bottom-up-Ansatz zu erhalten.
\end{algo}

\begin{algo}{Löschen in einem Heap}
    Das Entfernen eines Elements erfolgt, indem das gelöscht Element durch das letzte Element im Heap ersetzt wird. Dann wird das letzte Element aus dem Heap gelöscht. Nun wird das letzte Element an einer Stelle im Heap platziert.

    Es kann die Heap-Bedingung nicht erfüllen, sodass die Operation \emph{Down-Heapify} durchgeführt wird, um die Eigenschaften des Heaps aufrechtzuerhalten.
\end{algo}

\begin{defi}{Heapify}
    Heapify ist eine Operation, um die Elemente des Heaps neu anzuordnen, um die Heap-Bedingung aufrechtzuerhalten.

    Die Heapify kann in zwei Methoden erfolgen:
    \begin{itemize}
        \item Up-Heapify (erfolgt beim Einfügen)
        \item Down-Heapify (erfolgt beim Löschen)
    \end{itemize}

\end{defi}

\begin{algo}{Up-Heapify (Einfügen)}
    Einfügen der $90$ in \textcolor{red}{rot}.

    \vspace{1em}
    \begin{center}
        \scalebox{0.9}{
            \begin{forest}
                baseline,anchor=north,
                for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
                [
                90
                [
                36
                [
                25
                    [
                        2
                        %[,empty node]
                        %[,empty node]
                    ]
                    [
                        3
                        %[,empty node]
                        %[,empty node]
                    ]
                ]
                [
                26,draw=blue
                [
                19
                %[,empty node]
                %[,empty node]
                ]
                [45 ,edge={red,thick}, draw=red]
                {\draw[<->,blue] () to[bend right=45] node[midway,below right,font=\small]{Vertauschen} (!u.east);}
                ]
                ]
                [
                17
                    [
                        7
                            [,empty node]
                            [,empty node]
                    ]
                    [
                        1
                            [,empty node]
                            [,empty node]
                    ]
                ]
                ]
            \end{forest}
        }
        \hspace{1em}
        \scalebox{0.9}{
            \begin{forest}
                baseline,anchor=north,
                for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
                [
                90
                [
                36,draw=blue
                [
                25
                    [
                        2
                        %[,empty node]
                        %[,empty node]
                    ]
                    [
                        3
                        %[,empty node]
                        %[,empty node]
                    ]
                ]
                [
                45,edge={red,thick}, draw=red
                [
                19
                %[,empty node]
                %[,empty node]
                ]
                [26,edge={teal,thick}, draw=teal]
                ]
                {\draw[<->,blue] () to[bend right=45] node[midway,above right,font=\small]{Vertauschen} (!u.east);}
                ]
                [
                17
                    [
                        7
                            [,empty node]
                            [,empty node]
                    ]
                    [
                        1
                            [,empty node]
                            [,empty node]
                    ]
                ]
                ]
            \end{forest}
        }

        \vspace{1em}

        \scalebox{0.9}{
            \begin{forest}
                baseline,anchor=north,
                for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
                [
                90,draw=teal
                [
                45,edge={teal,thick}, draw=teal
                [
                25
                    [
                        2
                        %[,empty node]
                        %[,empty node]
                    ]
                    [
                        3
                        %[,empty node]
                        %[,empty node]
                    ]
                ]
                [
                36,edge={teal,thick}, draw=teal
                [
                19
                %[,empty node]
                %[,empty node]
                ]
                [26,edge={teal,thick}, draw=teal]
                ]
                ]
                [
                17
                    [
                        7
                            [,empty node]
                            [,empty node]
                    ]
                    [
                        1
                            [,empty node]
                            [,empty node]
                    ]
                ]
                ]
            \end{forest}
        }
    \end{center}
\end{algo}

\begin{algo}{Down-Heapify (Löschen)}
    Löschen der $90$ in \textcolor{red}{rot}.

    \vspace{1em}
    \begin{center}

        \scalebox{0.9}{
            \begin{forest}
                baseline,anchor=north,
                for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
                [
                90,draw=red
                [
                45
                    [
                        25
                            [
                                2
                                %[,empty node]
                                %[,empty node]
                            ]
                            [
                                3
                                %[,empty node]
                                %[,empty node]
                            ]
                    ]
                    [
                        36
                            [
                                19
                                %[,empty node]
                                %[,empty node]
                            ]
                            [26
                            ]
                    ]
                ]
                [
                17
                    [
                        7
                            [,empty node]
                            [,empty node]
                    ]
                    [
                        1
                            [,empty node]
                            [,empty node]
                    ]
                ]
                ]
            \end{forest}
        }
        \hspace{1em}
        \scalebox{0.9}{
            \begin{forest}
                baseline,anchor=north,
                for tree={circle, draw,
                        minimum size=2em, % <-- added
                        inner sep=1pt}
                    [
                        ,empty node, name=90
                            [
                                45
                                    [
                                        25
                                            [
                                                2
                                                %[,empty node]
                                                %[,empty node]
                                            ]
                                            [
                                                3
                                                %[,empty node]
                                                %[,empty node]
                                            ]
                                    ]
                                    [
                                        36
                                            [
                                                19
                                                %[,empty node]
                                                %[,empty node]
                                            ]
                                            [26, draw=blue, name=26
                                            ]
                                    ]
                            ]
                            [
                                17
                                    [
                                        7
                                            [,empty node]
                                            [,empty node]
                                    ]
                                    [
                                        1
                                            [,empty node]
                                            [,empty node]
                                    ]
                            ]
                    ]
                \draw[->, blue] (26) to[bend right=45] node[midway,above left,font=\small]{Nachrücken} (90);
            \end{forest}
        }

        \vspace{1em}

        \scalebox{0.9}{
            \begin{forest}
                baseline,anchor=north,
                for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
                [
                26, draw=red
                [
                45, edge={draw=red},draw=blue
                [
                25
                    [
                        2
                        %[,empty node]
                        %[,empty node]
                    ]
                    [
                        3
                        %[,empty node]
                        %[,empty node]
                    ]
                ]
                [
                36
                    [
                        19
                        %[,empty node]
                        %[,empty node]
                    ]
                    [,empty node]
                ]
                ]
                {\draw[<->,blue] () to[bend left=45] node[midway,above left,font=\small]{Vertauschen} (!u.west);}
                [
                17
                    [
                        7
                            [,empty node]
                            [,empty node]
                    ]
                    [
                        1
                            [,empty node]
                            [,empty node]
                    ]
                ]
                ]
            \end{forest}
        }
        \hspace{1em}
        \scalebox{0.9}{
            \begin{forest}
                baseline,anchor=north,
                for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
                [
                45,draw=teal
                [
                26, draw=red, edge={draw=teal}
                [
                25
                    [
                        2
                        %[,empty node]
                        %[,empty node]
                    ]
                    [
                        3
                        %[,empty node]
                        %[,empty node]
                    ]
                ]
                [
                36, edge={draw=red},draw=blue
                [
                19
                %[,empty node]
                %[,empty node]
                ]
                [,empty node]
                ]
                {\draw[<->,blue] () to[bend right=45] node[midway,above right,font=\small]{Vertauschen} (!u.east);}
                ]
                [
                17
                    [
                        7
                            [,empty node]
                            [,empty node]
                    ]
                    [
                        1
                            [,empty node]
                            [,empty node]
                    ]
                ]
                ]
            \end{forest}
        }

        \vspace{1em}

        \scalebox{0.9}{
            \begin{forest}
                baseline,anchor=north,
                for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
                [
                45,draw=teal
                [
                36, draw=teal, edge={draw=teal}
                [
                25
                    [
                        2
                        %[,empty node]
                        %[,empty node]
                    ]
                    [
                        3
                        %[,empty node]
                        %[,empty node]
                    ]
                ]
                [
                26, edge={draw=teal},draw=teal
                [
                19, edge={draw=teal},draw=teal
                %[,empty node]
                %[,empty node]
                ]
                [,empty node]
                ]
                ]
                [
                17
                    [
                        7
                            [,empty node]
                            [,empty node]
                    ]
                    [
                        1
                            [,empty node]
                            [,empty node]
                    ]
                ]
                ]
            \end{forest}
        }
    \end{center}
\end{algo}

% Baumdurchlauf

\section{Graphen}

\begin{defi}{Gerichteter Graph}
    Ein \emph{gerichteter Graph} $G = (V, E)$ besteht aus
    \begin{itemize}
        \item einer endlichen, nicht leeren Menge $V = \{v_1, \ldots, v_n\}$ von \emph{Knoten (vertices)} und
        \item einer Relation $E \subseteq V \times V$ von geordneten Paaren $e = (u, v)$ den \emph{Kanten (edges)}.
    \end{itemize}

    Jede Kante $(u,v) \in E$ hat einen Anfangsknoten $u$ und einen Enknoten $v$ und damit eine Richtung von $u$ nach $v$ ($u=v$ ist möglich).

    \begin{center}
        \begin{tikzpicture}[->]
            \node[draw, circle] (1) {1};
            \node[draw, circle, below=of 1] (2) {2};
            \node[draw, circle, right=of 2] (3) {3};
            \node[draw, circle, above=of 3] (4) {4};
            \node[draw, circle, right=of 4] (5) {5};

            %\draw[->] (1) to[bend left=15] (4);
            %\draw[->] (4) to[bend left=15] (1);
            %\draw[->] (1) to (2);
            %\draw[->] (2) to (3);
            %\draw[->] (3) to (4);
            %\draw[->] (4) to (5);

            \path (1) edge[bend left=15] (4);
            \path (4) edge[bend left=15] (1);
            \path (1) edge (2);
            \path (2) edge (3);
            \path (3) edge (4);
            \path (4) edge (5);
            \path (5) edge[loop above] (5);
        \end{tikzpicture}
    \end{center}
\end{defi}

\begin{defi}{Ungerichteter Graph}
    Ein \emph{ungerichteter Graph} $G = (V, E)$ besteht aus
    \begin{itemize}
        \item einer endlichen, nicht leeren Menge $V = \{v_1, \ldots, v_n\}$ von \emph{Knoten (vertices)} und
        \item einer symmetrischen Relation $E \subseteq V \times V$ von geordneten Paaren $e = (u, v) \iff (v, u)$ den \emph{Kanten (edges)}.
    \end{itemize}

    Jede Kante $(u,v) \in E$ hat einen Anfangsknoten $u$ und einen Enknoten $v$ und damit eine Richtung von $u$ nach $v$ ($u=v$ ist möglich).

    \vspace{1em}
    \begin{center}
        \begin{tikzpicture}
            \node[draw, circle] (1) {1};
            \node[draw, circle, below=of 1] (2) {2};
            \node[draw, circle, right=of 2] (3) {3};
            \node[draw, circle, above=of 3] (4) {4};
            \node[draw, circle, right=of 4] (5) {5};

            %\draw[->] (1) to[bend left=15] (4);
            %\draw[->] (4) to[bend left=15] (1);
            %\draw[->] (1) to (2);
            %\draw[->] (2) to (3);
            %\draw[->] (3) to (4);
            %\draw[->] (4) to (5);

            \path (1) edge (4);
            \path (1) edge (2);
            \path (2) edge (3);
            \path (3) edge (4);
            \path (4) edge (5);
        \end{tikzpicture}
    \end{center}
\end{defi}

\begin{defi}{Gewichteter Graph}
    Ein Graph heißt \emph{gewichtet}, wenn jeder Kante ein Wert als \emph{Gewicht} zugeordnet ist (z.B. Transportkosten, Entfernung).

    \begin{center}
        \begin{tikzpicture}[->]
            \node[draw, circle] (1) {1};
            \node[draw, circle, below=of 1] (2) {2};
            \node[draw, circle, right=of 2] (3) {3};
            \node[draw, circle, above=of 3] (4) {4};
            \node[draw, circle, right=of 4] (5) {5};

            %\draw[->] (1) to[bend left=15] (4);
            %\draw[->] (4) to[bend left=15] (1);
            %\draw[->] (1) to (2);
            %\draw[->] (2) to (3);
            %\draw[->] (3) to (4);
            %\draw[->] (4) to (5);

            \path (1) edge[bend left=15] node[above,scale=0.7] {2} (4);
            \path (4) edge[bend left=15] node[below,scale=0.7] {1} (1);
            \path (1) edge node[left,scale=0.7] {2} (2);
            \path (2) edge node[above,scale=0.7] {1} (3);
            \path (3) edge node[right,scale=0.7] {8} (4);
            \path (4) edge node[above,scale=0.7] {1} (5);
            \path (5) edge[loop above] node[above,scale=0.7] {2} (5);
        \end{tikzpicture}
    \end{center}
\end{defi}

\begin{defi}{Teilgraph}
    $G' = (V', E')$ heißt \emph{Teilgraph} von $G=(V, E)$, wenn gilt:
    $$
        V' \subseteq V \quad \text{und} \quad E' \subseteq E
    $$
\end{defi}

\begin{defi}{Weg}
    Sei $G = (V, E)$ ein Graph.

    Eine Folge von Knoten
    $$
        W := (v_1, v_2, \ldots, v_n)
    $$
    heißt \emph{Weg} oder \emph{Pfad} in $G$, falls gilt:
    $$
        \forall 1 \leq i \leq n-1 : (v_i, v_{i+1}) \in E
    $$
    (also eine Folge von zusammenhängenden Kanten)

    $\alpha(W) := v_1$ heißt \emph{Anfangsknoten} des Weges $W$.

    $\omega(W) := v_n$ heißt \emph{Endknoten} des Weges $W$.

    $\forall v_i \in V : (v_i)$ heißt \emph{trivialer Weg} und ist stets ein Weg in $G$.

    Die \emph{Länge eines Weges} ist $l(W) := n-1$, falls $n$ Knoten auf diesem Weg besucht werden.

    Ein Weg heißt \emph{einfacher Weg}, wenn kein Knoten (ausgenommen Start- und Endknoten) mehr als einmal vorkommt.

    Ein \emph{Zykel} oder \emph{Kreis} ist ein nicht-trivialer einfacher Weg mit der Bedingung $\alpha(W) = \omega(W)$.
\end{defi}

\begin{defi}{Adjazenz}
    Zwei Knoten heißen \emph{adjazent (benachbart)}, wenn sie eine Kante verbindet.
\end{defi}

\begin{bonus}{Speicherung von Graphen}
    \begin{itemize}
        \item Kantenorientiert
              \begin{itemize}
                  \item Index für Kanten
                  \item für jede Kante speichern: Vorgänger-, Nachfolgerknoten (Markierung, Gewicht)
                  \item meist statische Darstellung, z.B. Kantenliste
              \end{itemize}
        \item Knotenorientiert
              \begin{itemize}
                  \item gebräuchlicher als kantenorientiert
                  \item in vielen Ausprägungen, z.B. Knotenliste, Adjazenzmatrix, Adjazenzliste
                  \item für Adjazenzmatrix gilt:
                        $$
                            A_{ij} = \begin{cases}
                                1 & \text{, falls} \ (i, j) \in E \\
                                0 & \text{, sonst}
                            \end{cases}
                        $$
              \end{itemize}
    \end{itemize}
\end{bonus}

\begin{example}{Adjazenzmatrix}
    \begin{center}
        \begin{tikzpicture}[->]
            \node[draw, circle] (1) {1};
            \node[draw, circle, below left=of 1] (3) {3};
            \node[draw, circle, below right=of 1] (4) {4};
            \node[draw, circle, above right=of 4] (2) {2};
            \node[draw, circle, below=of 3] (5) {5};
            \node[draw, circle, below=of 4] (6) {6};

            \path (5) edge[loop below] (5);
            \path (1) edge[bend left=15] (3);
            \path (3) edge[bend left=15] (1);
            \path (4) edge (1);
            \path (1) edge (2);
            \path (3) edge (4);
            \path (5) edge (3);
            \path (3) edge (6);
            \path (6) edge (4);
            \path (6) edge (5);
            \path (6) edge (2);
        \end{tikzpicture}
    \end{center}

    Für den Graphen $G$ oben gilt die Adjazenzmatrix:
    $$
        A(G) = \vektor{
            0 & 1 & 1 & 0 & 0 & 0 \\
            0 & 0 & 0 & 0 & 0 & 0 \\
            1 & 0 & 0 & 1 & 0 & 1 \\
            1 & 0 & 0 & 0 & 0 & 0 \\
            0 & 0 & 1 & 0 & 1 & 0 \\
            0 & 1 & 0 & 1 & 1 & 0
        }
    $$
\end{example}

\begin{example}{Adjazenzliste}
    \begin{center}
        \begin{tikzpicture}[->]
            \node[draw, circle] (1) {1};
            \node[draw, circle, below left=of 1] (3) {3};
            \node[draw, circle, below right=of 1] (4) {4};
            \node[draw, circle, above right=of 4] (2) {2};
            \node[draw, circle, below=of 3] (5) {5};
            \node[draw, circle, below=of 4] (6) {6};

            \path (5) edge[loop below] (5);
            \path (1) edge[bend left=15] (3);
            \path (3) edge[bend left=15] (1);
            \path (4) edge (1);
            \path (1) edge (2);
            \path (3) edge (4);
            \path (5) edge (3);
            \path (3) edge (6);
            \path (6) edge (4);
            \path (6) edge (5);
            \path (6) edge (2);
        \end{tikzpicture}
    \end{center}

    Für den Graphen $G$ oben gilt die Adjazenzliste:

    \vspace{1em}

    \begin{center}
        \begin{tikzpicture}[
            start chain = going below,
            StackBlock/.style={minimum width=2em, minimum height=2em, outer sep=0pt, on chain},
            every node/.style={draw, label distance=0.5em},
            node distance=0em
            ]
            {
            \node [StackBlock] (k1) {$1$};
            \node [StackBlock,yshift=-0.5em] (k2) {$2$};
            \node [StackBlock,yshift=-0.5em] (k3) {$3$};
            \node [StackBlock,yshift=-0.5em] (k4) {$4$};
            \node [StackBlock,yshift=-0.5em] (k5) {$5$};
            \node [StackBlock,yshift=-0.5em] (k6) {$6$};

            % Chain 1
            { [continue chain = going right]
            \chainin (k1);

            \node [StackBlock, xshift=2em] (12) {$2$};
            \node [StackBlock] (12p) {};
            \node [StackBlock, xshift=2em] (13) {$3$};
            \node [StackBlock] (13p) {};
            }

            % Chain 3
            { [continue chain = going right]
            \chainin (k3);

            \node [StackBlock, xshift=2em] (31) {$1$};
            \node [StackBlock] (31p) {};
            \node [StackBlock, xshift=2em] (34) {$4$};
            \node [StackBlock] (34p) {};
            \node [StackBlock, xshift=2em] (36) {$6$};
            \node [StackBlock] (36p) {};
            }

            % Chain 4
            { [continue chain = going right]
            \chainin (k4);

            \node [StackBlock, xshift=2em] (41) {$1$};
            \node [StackBlock] (41p) {};
            }

            % Chain 5
            { [continue chain = going right]
            \chainin (k5);

            \node [StackBlock, xshift=2em] (53) {$3$};
            \node [StackBlock] (53p) {};
            \node [StackBlock, xshift=2em] (55) {$5$};
            \node [StackBlock] (55p) {};
            }

            % Chain 6
            { [continue chain = going right]
            \chainin (k6);

            \node [StackBlock, xshift=2em] (62) {$2$};
            \node [StackBlock] (62p) {};
            \node [StackBlock, xshift=2em] (64) {$4$};
            \node [StackBlock] (64p) {};
            \node [StackBlock, xshift=2em] (65) {$5$};
            \node [StackBlock] (65p) {};
            }

            \draw[->] (k1.east) [out=0, in=180] to (12.west);
            \draw[->] (k3.east) [out=0, in=180] to (31.west);
            \draw[->] (k4.east) [out=0, in=180] to (41.west);
            \draw[->] (k5.east) [out=0, in=180] to (53.west);
            \draw[->] (k6.east) [out=0, in=180] to (62.west);

            \draw[->] (12p.center) [out=0, in=180] to (13.west);

            \draw[->] (31p.center) [out=0, in=180] to (34.west);
            \draw[->] (34p.center) [out=0, in=180] to (36.west);

            \draw[->] (53p.center) [out=0, in=180] to (55.west);

            \draw[->] (62p.center) [out=0, in=180] to (64.west);
            \draw[->] (64p.center) [out=0, in=180] to (65.west);
            }
        \end{tikzpicture}
    \end{center}
\end{example}

\subsection{Suche}

\begin{algo}{Breitensuche}
    \begin{enumerate}
        \item Zunächst werden alle Knoten als \glqq noch nicht besucht\grqq markiert.
        \item Startpunkt $v$ wählen und als \glqq besucht\grqq markieren.
        \item Jetzt:
              \begin{enumerate}
                  \item alle von $v$ aus direkt erreichbaren (nicht besuchten) Knoten \glqq besuchen\grqq
                  \item alle von $v$ über zwei Kanten erreichbaren (nicht besuchten) Knoten \glqq besuchen\grqq
                  \item $\ldots$
              \end{enumerate}
        \item Wenn noch nicht alle Knoten besucht worden sind, wähle einen neuen unbesuchten Startpunkt $v$ und beginne bei Schritt 3
    \end{enumerate}

    Start bei Knoten 1.

    \begin{center}
        \begin{tikzpicture}[->]
            \node[draw, circle, current] (1) {1};
            \node[draw, circle, below left=of 1] (3) {3};
            \node[draw, circle, below right=of 1] (4) {4};
            \node[draw, circle, above right=of 4] (2) {2};
            \node[draw, circle, below=of 3] (5) {5};
            \node[draw, circle, below=of 4] (6) {6};

            \path (5) edge[loop below] (5);
            \path (1) edge[bend left=15] (3);
            \path (3) edge[bend left=15] (1);
            \path (4) edge (1);
            \path (1) edge (2);
            \path (3) edge (4);
            \path (5) edge (3);
            \path (3) edge (6);
            \path (6) edge (4);
            \path (6) edge (5);
            \path (6) edge (2);
        \end{tikzpicture}
        %
        \hspace{5em}
        %
        \begin{tikzpicture}[->]
            \node[draw, circle, visited] (1) {1};
            \node[draw, circle, below left=of 1, current] (3) {3};
            \node[draw, circle, below right=of 1] (4) {4};
            \node[draw, circle, above right=of 4, current] (2) {2};
            \node[draw, circle, below=of 3] (5) {5};
            \node[draw, circle, below=of 4] (6) {6};

            \path (5) edge[loop below] (5);
            \path (1) edge[bend left=15] (3);
            \path (3) edge[bend left=15] (1);
            \path (4) edge (1);
            \path (1) edge (2);
            \path (3) edge (4);
            \path (5) edge (3);
            \path (3) edge (6);
            \path (6) edge (4);
            \path (6) edge (5);
            \path (6) edge (2);
        \end{tikzpicture}
        %
        %\hspace{5em}
        %
        \begin{tikzpicture}[->]
            \node[draw, circle, visited] (1) {1};
            \node[draw, circle, below left=of 1, visited] (3) {3};
            \node[draw, circle, below right=of 1, current] (4) {4};
            \node[draw, circle, above right=of 4, visited] (2) {2};
            \node[draw, circle, below=of 3] (5) {5};
            \node[draw, circle, below=of 4, current] (6) {6};

            \path (5) edge[loop below] (5);
            \path (1) edge[bend left=15] (3);
            \path (3) edge[bend left=15] (1);
            \path (4) edge (1);
            \path (1) edge (2);
            \path (3) edge (4);
            \path (5) edge (3);
            \path (3) edge (6);
            \path (6) edge (4);
            \path (6) edge (5);
            \path (6) edge (2);
        \end{tikzpicture}
        %
        \hspace{5em}
        %
        \begin{tikzpicture}[->]
            \node[draw, circle, visited] (1) {1};
            \node[draw, circle, below left=of 1, visited] (3) {3};
            \node[draw, circle, below right=of 1, visited] (4) {4};
            \node[draw, circle, above right=of 4, visited] (2) {2};
            \node[draw, circle, below=of 3, current] (5) {5};
            \node[draw, circle, below=of 4, visited] (6) {6};

            \path (5) edge[loop below] (5);
            \path (1) edge[bend left=15] (3);
            \path (3) edge[bend left=15] (1);
            \path (4) edge (1);
            \path (1) edge (2);
            \path (3) edge (4);
            \path (5) edge (3);
            \path (3) edge (6);
            \path (6) edge (4);
            \path (6) edge (5);
            \path (6) edge (2);
        \end{tikzpicture}
        %
        %\hspace{5em}
        %
        \begin{tikzpicture}[->]
            \node[draw, circle, visited] (1) {1};
            \node[draw, circle, below left=of 1, visited] (3) {3};
            \node[draw, circle, below right=of 1, visited] (4) {4};
            \node[draw, circle, above right=of 4, visited] (2) {2};
            \node[draw, circle, below=of 3, visited] (5) {5};
            \node[draw, circle, below=of 4, visited] (6) {6};

            \path (5) edge[loop below] (5);
            \path (1) edge[bend left=15] (3);
            \path (3) edge[bend left=15] (1);
            \path (4) edge (1);
            \path (1) edge (2);
            \path (3) edge (4);
            \path (5) edge (3);
            \path (3) edge (6);
            \path (6) edge (4);
            \path (6) edge (5);
            \path (6) edge (2);
        \end{tikzpicture}
    \end{center}
\end{algo}

\begin{algo}{Tiefensuche}
    \begin{enumerate}
        \item Zunächst alle Knoten als \glqq noch nicht besucht\grqq markieren.
        \item Startpunkt $v$ wählen und als \glqq besucht\grqq markieren.
        \item Von dort aus möglichst langen Pfad entlang gehen; dabei nur bisher nicht besuchte Knoten \glqq besuchen\grqq
        \item Wenn dann noch nicht alle Knoten besucht worden sind, wähle einen neuen unbesuchten Startpunkt $v$ und beginne bei Schritt 3
    \end{enumerate}

    Start bei Knoten 1.

    \begin{center}
        \begin{tikzpicture}[->]
            \node[draw, circle, current] (1) {1};
            \node[draw, circle, below left=of 1] (3) {3};
            \node[draw, circle, below right=of 1] (4) {4};
            \node[draw, circle, above right=of 4] (2) {2};
            \node[draw, circle, below=of 3] (5) {5};
            \node[draw, circle, below=of 4] (6) {6};

            \path (5) edge[loop below] (5);
            \path (1) edge[bend left=15] (3);
            \path (3) edge[bend left=15] (1);
            \path (4) edge (1);
            \path (1) edge (2);
            \path (3) edge (4);
            \path (5) edge (3);
            \path (3) edge (6);
            \path (6) edge (4);
            \path (6) edge (5);
            \path (6) edge (2);
        \end{tikzpicture}
        %
        \hspace{5em}
        %
        \begin{tikzpicture}[->]
            \node[draw, circle, visited] (1) {1};
            \node[draw, circle, below left=of 1] (3) {3};
            \node[draw, circle, below right=of 1] (4) {4};
            \node[draw, circle, above right=of 4, current] (2) {2};
            \node[draw, circle, below=of 3] (5) {5};
            \node[draw, circle, below=of 4] (6) {6};

            \path (5) edge[loop below] (5);
            \path (1) edge[bend left=15] (3);
            \path (3) edge[bend left=15] (1);
            \path (4) edge (1);
            \path (1) edge (2);
            \path (3) edge (4);
            \path (5) edge (3);
            \path (3) edge (6);
            \path (6) edge (4);
            \path (6) edge (5);
            \path (6) edge (2);
        \end{tikzpicture}
        %
        %\hspace{5em}
        %
        \begin{tikzpicture}[->]
            \node[draw, circle, visited] (1) {1};
            \node[draw, circle, below left=of 1, current] (3) {3};
            \node[draw, circle, below right=of 1] (4) {4};
            \node[draw, circle, above right=of 4, visited] (2) {2};
            \node[draw, circle, below=of 3] (5) {5};
            \node[draw, circle, below=of 4] (6) {6};

            \path (5) edge[loop below] (5);
            \path (1) edge[bend left=15] (3);
            \path (3) edge[bend left=15] (1);
            \path (4) edge (1);
            \path (1) edge (2);
            \path (3) edge (4);
            \path (5) edge (3);
            \path (3) edge (6);
            \path (6) edge (4);
            \path (6) edge (5);
            \path (6) edge (2);
        \end{tikzpicture}
        %
        \hspace{5em}
        %
        \begin{tikzpicture}[->]
            \node[draw, circle, visited] (1) {1};
            \node[draw, circle, below left=of 1, visited] (3) {3};
            \node[draw, circle, below right=of 1, current] (4) {4};
            \node[draw, circle, above right=of 4, visited] (2) {2};
            \node[draw, circle, below=of 3] (5) {5};
            \node[draw, circle, below=of 4] (6) {6};

            \path (5) edge[loop below] (5);
            \path (1) edge[bend left=15] (3);
            \path (3) edge[bend left=15] (1);
            \path (4) edge (1);
            \path (1) edge (2);
            \path (3) edge (4);
            \path (5) edge (3);
            \path (3) edge (6);
            \path (6) edge (4);
            \path (6) edge (5);
            \path (6) edge (2);
        \end{tikzpicture}
        %
        %\hspace{5em}
        %
        \begin{tikzpicture}[->]
            \node[draw, circle, visited] (1) {1};
            \node[draw, circle, below left=of 1, visited] (3) {3};
            \node[draw, circle, below right=of 1, visited] (4) {4};
            \node[draw, circle, above right=of 4, visited] (2) {2};
            \node[draw, circle, below=of 3] (5) {5};
            \node[draw, circle, below=of 4, current] (6) {6};

            \path (5) edge[loop below] (5);
            \path (1) edge[bend left=15] (3);
            \path (3) edge[bend left=15] (1);
            \path (4) edge (1);
            \path (1) edge (2);
            \path (3) edge (4);
            \path (5) edge (3);
            \path (3) edge (6);
            \path (6) edge (4);
            \path (6) edge (5);
            \path (6) edge (2);
        \end{tikzpicture}
        %
        \hspace{5em}
        %
        \begin{tikzpicture}[->]
            \node[draw, circle, visited] (1) {1};
            \node[draw, circle, below left=of 1, visited] (3) {3};
            \node[draw, circle, below right=of 1, visited] (4) {4};
            \node[draw, circle, above right=of 4, visited] (2) {2};
            \node[draw, circle, below=of 3, current] (5) {5};
            \node[draw, circle, below=of 4, visited] (6) {6};

            \path (5) edge[loop below] (5);
            \path (1) edge[bend left=15] (3);
            \path (3) edge[bend left=15] (1);
            \path (4) edge (1);
            \path (1) edge (2);
            \path (3) edge (4);
            \path (5) edge (3);
            \path (3) edge (6);
            \path (6) edge (4);
            \path (6) edge (5);
            \path (6) edge (2);
        \end{tikzpicture}
        %
        %\hspace{5em}
        %
        \begin{tikzpicture}[->]
            \node[draw, circle, visited] (1) {1};
            \node[draw, circle, below left=of 1, visited] (3) {3};
            \node[draw, circle, below right=of 1, visited] (4) {4};
            \node[draw, circle, above right=of 4, visited] (2) {2};
            \node[draw, circle, below=of 3, visited] (5) {5};
            \node[draw, circle, below=of 4, visited] (6) {6};

            \path (5) edge[loop below] (5);
            \path (1) edge[bend left=15] (3);
            \path (3) edge[bend left=15] (1);
            \path (4) edge (1);
            \path (1) edge (2);
            \path (3) edge (4);
            \path (5) edge (3);
            \path (3) edge (6);
            \path (6) edge (4);
            \path (6) edge (5);
            \path (6) edge (2);
        \end{tikzpicture}
    \end{center}
\end{algo}

\begin{defi}{Level-Order-Baumdurchlauf}
    Führt man eine Breitensuche bei Bäumen aus, stellt man fest:
    \begin{itemize}
        \item Es ist nicht nötig, die Knoten zu markieren.
        \item Der Baum wird Ebene für Ebene durchlaufen,
    \end{itemize}

    Diesen Durchlauf nennt man \emph{Level-Order-Durchlauf}.
\end{defi}

\begin{defi}{Pre-Order-Baumdurchlauf}
    Führt man eine Tiefensuche bei Bäumen aus, nennt man diesen Durchlauf \emph{Pre-Order-Durchlauf}.

    Dabei wird stets der linke Teilbaum zuerst durchlaufen.
\end{defi}

\begin{defi}{Post-Order-Baumdurchlauf}
    \begin{enumerate}
        \item Durchlaufe linken Teilbaum
        \item Durchlaufe rechten Teilbaum
        \item Betrachte die Wurzel
    \end{enumerate}
\end{defi}

\begin{defi}{In-Order-Baumdurchlauf}
    \begin{enumerate}
        \item Durchlaufe linken Teilbaum
        \item Betrachte die Wurzel
        \item Durchlaufe rechten Teilbaum
    \end{enumerate}
\end{defi}

\begin{example}{Baumdurchläufe}
    \begin{center}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    45
                        [
                            36
                                [
                                    25
                                        [
                                            2
                                        ]
                                        [
                                            3
                                        ]
                                ]
                                [
                                    26
                                        [
                                            19
                                        ]
                                ]
                        ]
                        [
                            17
                                [
                                    7
                                ]
                                [
                                    1
                                ]
                        ]
                ]
        \end{forest}
    \end{center}

    Für den gegebenen Baum gelten folgende Baumdurchläufe:

    \centering
    \begin{tabular}{|l|cccccccccc|}
        \hline
        Pre-Order   & 45 & 36 & 25 & 2  & 3  & 26 & 19 & 17 & 7  & 1  \\
        \hline
        In-Order    & 2  & 25 & 3  & 19 & 26 & 36 & 45 & 7  & 17 & 1  \\
        \hline
        Post-Order  & 2  & 3  & 25 & 19 & 26 & 36 & 7  & 1  & 17 & 45 \\
        \hline
        Level-Order & 45 & 36 & 17 & 25 & 26 & 7  & 1  & 2  & 3  & 19 \\
        \hline
    \end{tabular}
\end{example}


\subsection{Entwurfsprinzipien}

\begin{defi}{Traveling-Salesman-Problem}
    Das \emph{Traveling-Salesman-Problem} ist ein Optimierungsproblem.
    Die Aufgabe besteht darin, eine Reihenfolge für den Besuch mehrerer Orte so zu wählen, dass:
    \begin{itemize}
        \item kein Ort doppelt besucht wird und
        \item die Reisestrecke minimal ist.
    \end{itemize}
\end{defi}

\begin{defi}{Greedy}
    Wähle immer den Schritt, desse unmittelbarer Folgezustand das beste Ergebnis liefert.
    Denke nicht an die weiteren Schritte (greedy = gierig).

    Ob ein Greedy-Algorithmus die optimale Lösung liefert oder nicht, ist vom konkreten Problem abhängig.

    Für das Traveling-Salesman-Problem ist eine Greedy-Lösung z.B. die \emph{Nearest-Neighbour-Lösung}:
    \begin{itemize}
        \item Gehe in jedem Schritt zur nächstliegenden Stadt, die noch nicht besucht ist.
        \item $\bigo(n^2)$
        \item liefert nicht die optimale Lösung (kann sogar beliebig schlecht werden)
        \item arbeitet meistens einigermaßen gut
    \end{itemize}
\end{defi}

\begin{bonus}{Random Insertion}
    Wähle immer einen zufälligen Knoten.

    \begin{itemize}
        \item $\bigo(n^2)$
        \item keine Garantie, dass die Lösung irgendeinem Gütekriterium genügt
        \item im Allgmeinen ist Lösung ziemlich gut
        \item Vorteil: Durch den Zufallsfaktor kann man das Verfahren beliebig oft wiederholen und sich die beste Lösung heraussuchen.
    \end{itemize}
\end{bonus}

\begin{bonus}{Lösung mit minimalem Spannbaum}
    \begin{enumerate}
        \item Konstruktion eines minimalen Spannbaums nach Prim
        \item Durchlaufen mit Tiefensuche
        \item jede Kante wird zweimal durchlaufen
        \item summierte Gewichte des minimalen Spannbaums müssen kleiner sein als das optimale TSP-Ergebnis
        \item Optimierung:
              \begin{itemize}
                  \item Knoten schon einmal besucht: beim nächsten Mal überspringen
                  \item bei einem Schritt mehrere Möglichkeiten: zuerst kürzeren Weg wählen (greedy)
              \end{itemize}
    \end{enumerate}
\end{bonus}

\begin{defi}{Backtracking}
    Durchlauf eines Lösungsbaum in Pre-Order-Reihenfolge.

    Situation: Mehrere Alternativen sind in bestimmten Schritten des Algorithmus möglich.

    Lösung mit \emph{Backtracking}:
    \begin{enumerate}
        \item Wähle eine Alternative und verfolge dieses Weg weiter.
        \item Falls man so eine Lösung des Problems findet, ist man fertig.
        \item Ansonsten gehe einen Schritt zurück und verfolge rekursiv eine andere (nicht versuchte) Alternative in diesem Schritt.
        \item Falls alle Alternativen erfolglos probiert wurden, einen Schritt zurückgehen $\ldots$
    \end{enumerate}

    Backtracking-Algorithmen können exponentiellen Aufwand haben.

    Tipps:
    \begin{itemize}
        \item Durch Einführung von Zusatzbedingungen möglichst viele Sackgassen ausschließen.
        \item Symmetriebedingungen ausnutzen.
    \end{itemize}
\end{defi}

\begin{defi}{Branch and Bound}
    \begin{enumerate}
        \item Ermitteln einer oberen Schranke (greedy)
        \item Falls dieser Wert überschritten wird, kann man die Suche auf diesem Pfad abbrechen.
        \item Bessere Lösungen nutzen, um die Schranke zu verbessern.
    \end{enumerate}
\end{defi}


\subsection{Graphalgorithmen}

\begin{defi}{Bipartiter Graph}
    Ein Graph $G=(V, E)$ heißt \emph{bipartit}, wenn man $V$ in disjunkte Mengen $U$ und $W$ zerlegen kann, so dass alle Kanten zwischen $U$ und $W$ verlaufen.

    Die Knoten eines bipartiten Graphen lassen sich mit zwei Farben so einfärben, dass zwei Nachbarknoten immer unterschiedlich eingefärbt sind.
\end{defi}

\begin{algo}{Prüfung ob ein Graph bipartit ist}
    \begin{enumerate}
        \item Einfärben des 1. Knotens
        \item Durchlauf mit Breitensuche
        \item Abwechselndes Färben
    \end{enumerate}

    Start bei Knoten 1.

    \vspace{1em}

    \begin{center}
        \begin{tikzpicture}
            \node[draw, circle, text=white, fill = blue!50] (1) {1};
            \node[draw, circle, right=of 1] (2) {2};
            \node[draw, circle, right=of 2] (3) {3};
            \node[draw, circle, below=of 1] (4) {4};
            \node[draw, circle, right=of 4] (5) {5};
            \node[draw, circle, below=of 4] (6) {6};
            \node[draw, circle, right=of 6] (7) {7};

            \path (1) edge (2);
            \path (2) edge (3);
            \path (1) edge (4);
            \path (4) edge (5);
            \path (2) edge (5);
            \path (4) edge (6);
            \path (6) edge (7);
            \path (3) edge[bend left=30] (7);
        \end{tikzpicture}
        %
        \hspace{5em}
        %
        \begin{tikzpicture}
            \node[draw, circle, text=white, fill = blue!50] (1) {1};
            \node[draw, circle, text=white, right=of 1, fill = red!50] (2) {2};
            \node[draw, circle, right=of 2] (3) {3};
            \node[draw, circle, text=white, below=of 1, fill = red!50] (4) {4};
            \node[draw, circle, right=of 4] (5) {5};
            \node[draw, circle, below=of 4] (6) {6};
            \node[draw, circle, right=of 6] (7) {7};

            \path (1) edge (2);
            \path (2) edge (3);
            \path (1) edge (4);
            \path (4) edge (5);
            \path (2) edge (5);
            \path (4) edge (6);
            \path (6) edge (7);
            \path (3) edge[bend left=30] (7);
        \end{tikzpicture}

        \vspace{1em}

        \begin{tikzpicture}
            \node[draw, circle, text=white, fill = blue!50] (1) {1};
            \node[draw, circle, text=white, right=of 1, fill = red!50] (2) {2};
            \node[draw, circle, text=white, right=of 2, fill = blue!50] (3) {3};
            \node[draw, circle, text=white, below=of 1, fill = red!50] (4) {4};
            \node[draw, circle, text=white, right=of 4, fill = blue!50] (5) {5};
            \node[draw, circle, text=white, below=of 4, fill = blue!50] (6) {6};
            \node[draw, circle, right=of 6] (7) {7};

            \path (1) edge (2);
            \path (2) edge (3);
            \path (1) edge (4);
            \path (4) edge (5);
            \path (2) edge (5);
            \path (4) edge (6);
            \path (6) edge (7);
            \path (3) edge[bend left=30] (7);
        \end{tikzpicture}
        %
        \hspace{5em}
        %
        \begin{tikzpicture}
            \node[draw, circle, text=white, fill = blue!50] (1) {1};
            \node[draw, circle, text=white, right=of 1, fill = red!50] (2) {2};
            \node[draw, circle, text=white, right=of 2, fill = blue!50] (3) {3};
            \node[draw, circle, text=white, below=of 1, fill = red!50] (4) {4};
            \node[draw, circle, text=white, right=of 4, fill = blue!50] (5) {5};
            \node[draw, circle, text=white, below=of 4, fill = blue!50] (6) {6};
            \node[draw, circle, text=white, right=of 6, fill = red!50] (7) {7};

            \path (1) edge (2);
            \path (2) edge (3);
            \path (1) edge (4);
            \path (4) edge (5);
            \path (2) edge (5);
            \path (4) edge (6);
            \path (6) edge (7);
            \path (3) edge[bend left=30] (7);
        \end{tikzpicture}
    \end{center}
\end{algo}

\begin{defi}{Spannbaum}
    Ein \emph{Spannbaum} verbindet alle Knoten eines ungerichteten Graphen miteinander, hat jedoch keine Kreise.

    Der \emph{minimale Spannbaum} ist der Spannbaum, dessen Kanten das kleinste summierte Gewicht haben.
\end{defi}

\begin{algo}{Prim-Algorithmus}
    \begin{enumerate}
        \item Wähle einen beliebigen Startknoten für den minimalen Spannbaum $T$
        \item Solange $T$ noch nicht alle Knoten enthält:
              \begin{itemize}
                  \item Wähle eine Kante $e$ mit minimalem Gewicht aus, die einen noch nicht in $T$ enthaltenen Knoten $v$ mit $T$ verbindet.
                  \item Füge $e$ und $v$ dem Graphen $T$ hinzu.
              \end{itemize}
    \end{enumerate}

    Start bei Knoten $A$.

    \vspace{1em}
    \begin{center}
        \begin{tikzpicture}
            \node[draw, circle, prim node] (A) {$A$};
            \node[draw, circle, below right=of A] (B) {$B$};
            \node[draw, circle, above right=of B] (C) {$C$};
            \node[draw, circle, below left=of B] (D) {$D$};
            \node[draw, circle, below right=of B] (E) {$E$};
            \node[draw, circle, below=of D] (F) {$F$};
            \node[draw, circle, below=of E] (G) {$G$};

            \path (A) edge node[weight,above right] {7} (B);
            \path (B) edge node[weight,above left] {8} (C);
            \path (D) edge node[weight,right] {5} (A);
            \path (D) edge node[weight,above left] {9} (B);
            \path (E) edge node[weight,above right] {7} (B);
            \path (C) edge node[weight,right] {5} (E);
            \path (D) edge node[weight,above] {15} (E);
            \path (D) edge node[weight,right] {6} (F);
            \path (E) edge node[weight,above left] {8} (F);
            \path (E) edge node[weight,right] {11} (G);
            \path (F) edge node[weight,above] {9} (G);
        \end{tikzpicture}
        %
        \hspace{3em}
        %
        \begin{tikzpicture}
            \node[draw, circle, prim node] (A) {$A$};
            \node[draw, circle, below right=of A] (B) {$B$};
            \node[draw, circle, above right=of B] (C) {$C$};
            \node[draw, circle, below left=of B, prim node] (D) {$D$};
            \node[draw, circle, below right=of B] (E) {$E$};
            \node[draw, circle, below=of D] (F) {$F$};
            \node[draw, circle, below=of E] (G) {$G$};

            \path (A) edge node[weight,above right] {7} (B);
            \path (B) edge node[weight,above left] {8} (C);
            \path (D) edge[prim edge] node[weight,right] {5} (A);
            \path (D) edge node[weight,above left] {9} (B);
            \path (E) edge node[weight,above right] {7} (B);
            \path (C) edge node[weight,right] {5} (E);
            \path (D) edge node[weight,above] {15} (E);
            \path (D) edge node[weight,right] {6} (F);
            \path (E) edge node[weight,above left] {8} (F);
            \path (E) edge node[weight,right] {11} (G);
            \path (F) edge node[weight,above] {9} (G);
        \end{tikzpicture}
        %
        \hspace{3em}
        %
        \begin{tikzpicture}
            \node[draw, circle, prim node] (A) {$A$};
            \node[draw, circle, below right=of A] (B) {$B$};
            \node[draw, circle, above right=of B] (C) {$C$};
            \node[draw, circle, below left=of B, prim node] (D) {$D$};
            \node[draw, circle, below right=of B] (E) {$E$};
            \node[draw, circle, below=of D, prim node] (F) {$F$};
            \node[draw, circle, below=of E] (G) {$G$};

            \path (A) edge node[weight,above right] {7} (B);
            \path (B) edge node[weight,above left] {8} (C);
            \path (D) edge[prim edge] node[weight,right] {5} (A);
            \path (D) edge node[weight,above left] {9} (B);
            \path (E) edge node[weight,above right] {7} (B);
            \path (C) edge node[weight,right] {5} (E);
            \path (D) edge node[weight,above] {15} (E);
            \path (D) edge[prim edge] node[weight,right] {6} (F);
            \path (E) edge node[weight,above left] {8} (F);
            \path (E) edge node[weight,right] {11} (G);
            \path (F) edge node[weight,above] {9} (G);
        \end{tikzpicture}
        %
        \vspace{1em}
        %

        \begin{tikzpicture}
            \node[draw, circle, prim node] (A) {$A$};
            \node[draw, circle, below right=of A, prim node] (B) {$B$};
            \node[draw, circle, above right=of B] (C) {$C$};
            \node[draw, circle, below left=of B, prim node] (D) {$D$};
            \node[draw, circle, below right=of B] (E) {$E$};
            \node[draw, circle, below=of D, prim node] (F) {$F$};
            \node[draw, circle, below=of E] (G) {$G$};

            \path (A) edge[prim edge] node[weight,above right] {7} (B);
            \path (B) edge node[weight,above left] {8} (C);
            \path (D) edge[prim edge] node[weight,right] {5} (A);
            \path (D) edge node[weight,above left] {9} (B);
            \path (E) edge node[weight,above right] {7} (B);
            \path (C) edge node[weight,right] {5} (E);
            \path (D) edge node[weight,above] {15} (E);
            \path (D) edge[prim edge] node[weight,right] {6} (F);
            \path (E) edge node[weight,above left] {8} (F);
            \path (E) edge node[weight,right] {11} (G);
            \path (F) edge node[weight,above] {9} (G);
        \end{tikzpicture}
        %
        \hspace{3em}
        %
        \begin{tikzpicture}
            \node[draw, circle, prim node] (A) {$A$};
            \node[draw, circle, below right=of A, prim node] (B) {$B$};
            \node[draw, circle, above right=of B] (C) {$C$};
            \node[draw, circle, below left=of B, prim node] (D) {$D$};
            \node[draw, circle, below right=of B, prim node] (E) {$E$};
            \node[draw, circle, below=of D, prim node] (F) {$F$};
            \node[draw, circle, below=of E] (G) {$G$};

            \path (A) edge[prim edge] node[weight,above right] {7} (B);
            \path (B) edge node[weight,above left] {8} (C);
            \path (D) edge[prim edge] node[weight,right] {5} (A);
            \path (D) edge node[weight,above left] {9} (B);
            \path (E) edge[prim edge] node[weight,above right] {7} (B);
            \path (C) edge node[weight,right] {5} (E);
            \path (D) edge node[weight,above] {15} (E);
            \path (D) edge[prim edge] node[weight,right] {6} (F);
            \path (E) edge node[weight,above left] {8} (F);
            \path (E) edge node[weight,right] {11} (G);
            \path (F) edge node[weight,above] {9} (G);
        \end{tikzpicture}
        %
        \hspace{3em}
        %
        \begin{tikzpicture}
            \node[draw, circle, prim node] (A) {$A$};
            \node[draw, circle, below right=of A, prim node] (B) {$B$};
            \node[draw, circle, above right=of B, prim node] (C) {$C$};
            \node[draw, circle, below left=of B, prim node] (D) {$D$};
            \node[draw, circle, below right=of B, prim node] (E) {$E$};
            \node[draw, circle, below=of D, prim node] (F) {$F$};
            \node[draw, circle, below=of E] (G) {$G$};

            \path (A) edge[prim edge] node[weight,above right] {7} (B);
            \path (B) edge node[weight,above left] {8} (C);
            \path (D) edge[prim edge] node[weight,right] {5} (A);
            \path (D) edge node[weight,above left] {9} (B);
            \path (E) edge[prim edge] node[weight,above right] {7} (B);
            \path (C) edge[prim edge] node[weight,right] {5} (E);
            \path (D) edge node[weight,above] {15} (E);
            \path (D) edge[prim edge] node[weight,right] {6} (F);
            \path (E) edge node[weight,above left] {8} (F);
            \path (E) edge node[weight,right] {11} (G);
            \path (F) edge node[weight,above] {9} (G);
        \end{tikzpicture}
        %
        \vspace{1em}
        %

        \begin{tikzpicture}
            \node[draw, circle, prim node] (A) {$A$};
            \node[draw, circle, below right=of A, prim node] (B) {$B$};
            \node[draw, circle, above right=of B, prim node] (C) {$C$};
            \node[draw, circle, below left=of B, prim node] (D) {$D$};
            \node[draw, circle, below right=of B, prim node] (E) {$E$};
            \node[draw, circle, below=of D, prim node] (F) {$F$};
            \node[draw, circle, below=of E, prim node] (G) {$G$};

            \path (A) edge[prim edge] node[weight,above right] {7} (B);
            \path (B) edge node[weight,above left] {8} (C);
            \path (D) edge[prim edge] node[weight,right] {5} (A);
            \path (D) edge node[weight,above left] {9} (B);
            \path (E) edge[prim edge] node[weight,above right] {7} (B);
            \path (C) edge[prim edge] node[weight,right] {5} (E);
            \path (D) edge node[weight,above] {15} (E);
            \path (D) edge[prim edge] node[weight,right] {6} (F);
            \path (E) edge node[weight,above left] {8} (F);
            \path (E) edge node[weight,right] {11} (G);
            \path (F) edge[prim edge] node[weight,above] {9} (G);
        \end{tikzpicture}
    \end{center}
\end{algo}

\begin{defi}{Shortest-Path-Probleme}
    Eigentlich: Suche nach \emph{günstigsten Wegen} in gewichteten Graphen: Gewichte $\simeq$ Kosten

    Bei Anwendung auf ungewichtete Graphen ergibt sich: \emph{kürzeste Wege}
\end{defi}

\begin{algo}{Dijkstra-Algorithmus}
    Gegeben: Graph $G = (V, E)$, dessen Bewertungsfunktion die Eigenschaften hat:
    \begin{itemize}
        \item Jede Kante von $v_i$ nach $v_j$ hat nicht-negative Kosten: $C(i, j) \geq 0$
        \item Falls keine Kante zwischen $v_i$ und $v_j$: $C(i, j) = \infty$
        \item Diagonalelemente: $C(i, i) = 0$
    \end{itemize}

    Menge $S$: die Knoten, deren günstigste Wegekosten von der vorgegebenen Quelle (Startknoten) bereits bekannt sind.

    \begin{enumerate}
        \item Initialisierung: $S = \{ \text{Startknoten} \}$
        \item Beginnend mit Quelle alle ausgehenden Kanten betrachten (analog Breitensuche). Nachfolgerknoten $v$ mit günstigster Kante zu $S$ hinzunehmen.
        \item Jetzt: Berechnen, ob die Knoten in $V \setminus S$ günstiger über $v$ als Zwischenweg erreichbar sind, als ohne Umweg über $v$.
        \item Danach: Denjenigen Knoten $v'$ zu $S$ hinzunehmen, der nun am günstigsten zu erreichen ist. Bei zwei gleich günstigen Knoten wird ein beliebiger davon ausgewählt.
        \item Ab Schritt 3 wiederholen, bis alle Knoten in $S$ sind.
    \end{enumerate}

    Zeitkomplexität (bei Speicherung des Graphen mit Adjazenzmatrix): $\bigo(\abs{V}^2)$
\end{algo}

\begin{example}{Dijkstra-Algorithmus}
    Der Spicker ist bereits ziemlich lang und ein Dijkstra-Beispiel würde Schritt für Schritt sehr viel Platz einnehmen.

    Daher hier nur einmal ein fertiges Beispiel, bzw. ein ausführliches YouTube-Video.

    \vspace{1em}
    \begin{center}
        \begin{tikzpicture}[->]
            \node[draw, circle] (A) {$A$};
            \node[draw, circle, below right=of A] (D) {$D$};
            \node[draw, circle, right=of D] (E) {$E$};
            \node[draw, circle, above right=of E] (B) {$B$};
            \node[draw, circle, below right=of B] (H) {$H$};
            \node[draw, circle, below left=of H] (G) {$G$};
            \node[draw, circle, below left=of A] (F) {$F$};
            \node[draw, circle, below right=of F] (C) {$C$};

            \path (A) edge node[weight, below left] {4} (D);
            \path (A) edge node[weight, above right] {2} (E);
            \path (A) edge node[weight, above right] {12} (B);
            \path (A) edge node[weight, above left] {30} (F);
            \path (E) edge node[weight, above] {1} (D);
            \path (E) edge node[weight, below right] {8} (C);
            \path (E) edge node[weight, above left] {8} (B);
            \path (C) edge node[weight, above right] {3} (F);
            \path (C) edge node[weight, above right] {3} (F);
            \path (C) edge node[weight, above] {12} (G);
            \path (G) edge node[weight, right] {4} (B);
            \path (G) edge node[weight, below right] {5} (H);
            \path (H) edge node[weight, above right] {2} (B);
        \end{tikzpicture}

        \vspace{1em}

        \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
            \hline
            \multirow{2}{*}{Schritt} & \multirow{2}{*}{Betrachteter Knoten} & \multicolumn{7}{c|}{Knoten}                             \\ \cline{3-9}
                                     &                                      & B                           & C  & D & E & F  & G  & H  \\
            \hline
            Initial                  & A                                    & 12                          &    & 4 & 2 & 30 &    &    \\
            1                        & E                                    & 10                          & 10 & 3 & 2 & 30 &    &    \\
            2                        & D                                    & 10                          & 10 & 3 & 2 & 30 &    &    \\
            3                        & B                                    & 10                          & 10 & 3 & 2 & 30 &    &    \\
            4                        & C                                    & 10                          & 10 & 3 & 2 & 13 & 22 &    \\
            5                        & F                                    & 10                          & 10 & 3 & 2 & 13 & 22 &    \\
            6                        & G                                    & 10                          & 10 & 3 & 2 & 13 & 22 & 27 \\
            7                        & H                                    & 10                          & 10 & 3 & 2 & 13 & 22 & 27 \\
            \hline
        \end{tabular}

        \vspace{1em}

        \begin{tabular}{|c|ccccccc|ccccccc|}
            \hline
            \multirow{2}{*}{$v_i$} & $d[2]$      & $d[3]$      & $d[4]$     & $d[5]$     & $d[6]$      & $d[7]$      & $d[8]$      & $p[2]$ & $p[3]$ & $p[4]$ & $p[5]$ & $p[6]$ & $p[7]$ & $p[8]$ \\ \cline{2-15}
                                   & B           & C           & D          & E          & F           & G           & H           & B      & C      & D      & E      & F      & G      & H      \\
            \hline
            A                      & 12          &             & 4          & \textbf{2} & 30          &             &             & A      &        & A      & A      & A      &        &        \\
            E                      & 10          & 10          & \textbf{3} & \textbf{2} & 30          &             &             & A      & E      & E      & A      & A      &        &        \\
            D                      & \textbf{10} & 10          & \textbf{3} & \textbf{2} & 30          &             &             & A      & E      & E      & A      & A      &        &        \\
            B                      & \textbf{10} & \textbf{10} & \textbf{3} & \textbf{2} & 30          &             &             & A      & E      & E      & A      & A      &        &        \\
            C                      & \textbf{10} & \textbf{10} & \textbf{3} & \textbf{2} & \textbf{13} & 22          &             & A      & E      & E      & A      & C      & C      &        \\
            F                      & \textbf{10} & \textbf{10} & \textbf{3} & \textbf{2} & \textbf{13} & \textbf{22} &             & A      & E      & E      & A      & C      & C      &        \\
            G                      & \textbf{10} & \textbf{10} & \textbf{3} & \textbf{2} & \textbf{13} & \textbf{22} & \textbf{27} & A      & E      & E      & A      & C      & C      & G      \\
            H                      & \textbf{10} & \textbf{10} & \textbf{3} & \textbf{2} & \textbf{13} & \textbf{22} & \textbf{27} & A      & E      & E      & A      & C      & C      & G      \\
            \hline
        \end{tabular}
    \end{center}

    \vspace{1em}

    \url{https://youtu.be/4pBP2hbnGso} (Herleitung und Erklärung)
\end{example}

\subsection{Floyd-Warshall-Algorithmus}

\section{Formale Sprachen}
% Textsuche

% Reguläre Ausdrücke

% PCRE

% Kleene

\section{Sortierverfahren}
\subsection{Heapsort}

\begin{defi}{Heapsort}
    Der Heap ist Grundlage für das Sortierverfahren \emph{Heapsort}.

    \begin{itemize}
        \item Zu Beginn: Unsortiertes Feld
        \item Phase 1:
              \begin{itemize}
                  \item Alle Elemente werden nacheinander in einen Heap eingefügt
                  \item Resultat ist ein Heap, der in ein Feld eingebettet ist
              \end{itemize}
        \item Phase 2:
              \begin{itemize}
                  \item Die Elemente werden in absteigender Reihenfolge entfernt (Wurzel!)
                  \item Heap schrumpft immer weiter
              \end{itemize}
    \end{itemize}

    \begin{center}
        \begin{tikzpicture}
            [
                start chain,
                node distance = 0pt,
                HeapBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain, fill=teal!30},
                SortedBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain, fill=blue!30},
            ]

            { start chain = going right
                \node [HeapBlock, label=above:\texttt{root}] (1) {$0$};
                \node [HeapBlock] (2) {$1$};
                \node [HeapBlock] (3) {$2$};
                \node [HeapBlock] (dots) {$\ldots$};
                \node [HeapBlock] (n2) {$n-2$};
                \node [HeapBlock] (n1) {$n-1$};
                \node [HeapBlock] (n) {$n$};

                \draw[->, blue] ([yshift=1em] 1.north east) to[bend left=30] ([yshift=.5em] n.north);

                \draw [decorate,decoration={brace,amplitude=5pt,mirror,raise=.5em}]
                (1.south west) -- (n.south east) node[midway,yshift=-2em]{Heap};
                %\draw[->] (val.south) [out=-30, in=-150] to (4.south);
            }
        \end{tikzpicture}
        \hspace{4em}
        \begin{tikzpicture}
            [
                start chain,
                node distance = 0pt,
                HeapBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain, fill=teal!30},
                SortedBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain, fill=blue!30},
            ]

            { start chain = going right
                \node [HeapBlock, label=above:\texttt{root}] (1) {$0$};
                \node [HeapBlock] (2) {$1$};
                \node [HeapBlock] (3) {$2$};
                \node [HeapBlock] (dots) {$\ldots$};
                \node [HeapBlock] (n2) {$n-2$};
                \node [HeapBlock] (n1) {$n-1$};
                \node [SortedBlock] (n) {$n$};

                \draw[->, blue] ([yshift=1em] 1.north east) to[bend left=30] ([yshift=.5em] n1.north);

                \draw [decorate,decoration={brace,amplitude=5pt,mirror,raise=.5em}]
                (1.south west) -- (n1.south east) node[midway,yshift=-2em]{Heap};

                \draw [decorate,decoration={brace,amplitude=5pt,mirror,raise=.5em}]
                (n.south west) -- (n.south east) node[midway,yshift=-2em]{sortiertes Array};
                %\draw[->] (val.south) [out=-30, in=-150] to (4.south);
            }
        \end{tikzpicture}

        \begin{tikzpicture}
            [
                start chain,
                node distance = 0pt,
                HeapBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain, fill=teal!30},
                SortedBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain, fill=blue!30},
            ]

            { start chain = going right
                \node [HeapBlock, label=above:\texttt{root}] (1) {$0$};
                \node [HeapBlock] (2) {$1$};
                \node [HeapBlock] (3) {$2$};
                \node [HeapBlock] (dots) {$\ldots$};
                \node [HeapBlock] (n2) {$n-2$};
                \node [SortedBlock] (n1) {$n-1$};
                \node [SortedBlock] (n) {$n$};
                \node [xshift=2em, on chain] (dots2) {$\ldots$};

                \draw[->, blue] ([yshift=1em] 1.north east) to[bend left=30] ([yshift=.5em] n2.north);

                \draw [decorate,decoration={brace,amplitude=5pt,mirror,raise=.5em}]
                (1.south west) -- (n2.south east) node[midway,yshift=-2em]{Heap};

                \draw [decorate,decoration={brace,amplitude=5pt,mirror,raise=.5em}]
                (n1.south west) -- (n.south east) node[midway,yshift=-2em]{sortiertes Array};
                %\draw[->] (val.south) [out=-30, in=-150] to (4.south);
            }
        \end{tikzpicture}
        \hspace{1em}
        \begin{tikzpicture}
            [
                start chain,
                node distance = 0pt,
                HeapBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain, fill=teal!30},
                SortedBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain, fill=blue!30},
            ]

            { start chain = going right
                \node [SortedBlock] (1) {$0$};
                \node [SortedBlock] (2) {$1$};
                \node [SortedBlock] (3) {$2$};
                \node [SortedBlock] (dots) {$\ldots$};
                \node [SortedBlock] (n2) {$n-2$};
                \node [SortedBlock] (n1) {$n-1$};
                \node [SortedBlock] (n) {$n$};

                %\draw[->, blue] ([yshift=1em] 1.north) to[bend left=30] ([yshift=.5em] n2.north);

                %\draw [decorate,decoration={brace,amplitude=5pt,mirror,raise=.5em}]
                %(1.south west) -- (n2.south east) node[midway,yshift=-2em]{Heap};

                \draw [decorate,decoration={brace,amplitude=5pt,mirror,raise=.5em}]
                (1.south west) -- (n.south east) node[midway,yshift=-2em]{sortiertes Array};
                %\draw[->] (val.south) [out=-30, in=-150] to (4.south);
            }
        \end{tikzpicture}
    \end{center}
\end{defi}

\subsection{Quicksort}

\subsection{Mergesort}

\subsection{Radixsort}


\printindex
\printindex[Beispiele]

\printbibliography
\end{document}
