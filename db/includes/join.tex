\section{Join}

\begin{defi}{Kartesisches Produkt}
    Wenn man alle Entitäten einer Tabelle mit jeder Entität aus einer anderen Tabelle kombinieren möchte, benötigt man das \emph{kartesische Produkt}.

    Möchte man jede mögliche Typkombination\footnote{Sollte man das kartesische Produkt einer Tabelle mit sich selbst bilden, benötigt man Aliase für die Tabellen} erhalten, nutzt man \texttt{SELECT} zwei mal auf \texttt{Typ}:

    \mint{mysql}|SELECT * FROM typ AS typ1, typ AS typ2;|

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_definition_join_kartesisches_produkt.txt}

    Wenn eine Relation verschiedener Tabellen über einen Fremdschlüssel realisiert ist, kann man Entitäten aus diesen Tabellen zueinander zuordnen.
    So wird nicht nur der Fremdschlüssel angezeigt, sondern alle zugehörigen Attribute.
    
    Da wir die aus dem kartesischen Produkt erhaltene Menge noch sinnvoll selektieren müssen, nutzen wir \texttt{WHERE}.

    In unserem Beispiel kann kein Pokemon zwei mal den selben Typen besitzen:

    \begin{minted}{mysql}
SELECT * FROM
    typ AS typ1,
    typ AS typ2
WHERE NOT typ1.Bezeichnung = typ2.Bezeichnung;
    \end{minted}

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_definition_join_kartesisches_produkt_where.txt}
\end{defi}

\begin{sql}{JOIN}
    Das selbe Ergebnis erhält man, wenn man \texttt{JOIN} mit dem Schlüsselwort \texttt{ON} nutzt:\footnote{
        Hierbei unterscheiden sich die beiden Abfragen ausschließlich in der Lesbarkeit und Optimierungsmöglichkeiten für das DBMS.
        Bei \texttt{JOIN} muss das DBMS nicht alle Kombinationen ermitteln, nur um diese dann zu filtern.
    }

    \begin{minted}{mysql}
SELECT * FROM
    typ AS typ1
JOIN
    typ AS typ2
ON NOT typ1.Bezeichnung = typ2.Bezeichnung;
    \end{minted}
\end{sql}

\begin{sql}{CROSS JOIN}
    \texttt{CROSS JOIN} gibt das unselektierte kartesische Produkt aus.

    Dementsprechend sind die folgenden Abfragen erneut äquivalent:

    \begin{minted}{mysql}
SELECT * FROM typ AS typ1 CROSS JOIN typ AS typ2;
SELECT * FROM typ AS typ1 JOIN typ as typ2 ON TRUE;
SELECT * FROM typ AS typ1, typ AS typ2;
    \end{minted}
\end{sql}

\begin{sql}{INNER JOIN}
    \texttt{INNER JOIN} wird automatisch genutzt, wenn man \texttt{JOIN} nutzt.

    Dementsprechend sind folgende abfragen äquivalent:

    \begin{minted}{mysql}
SELECT * FROM typ AS typ1 JOIN typ AS typ2
    ON NOT typ1.Bezeichnung = typ2.Bezeichnung;
SELECT * FROM typ AS typ1 INNER JOIN typ AS typ2
    ON NOT typ1.Bezeichnung = typ2.Bezeichnung;
    \end{minted}

    Wenn man sich beispielsweise alle Pokémon samt ihrer Entwicklung anzeigen lassen möchte, so erhält man:

    \begin{minted}{mysql}
SELECT
    pokemon.ID, pokemon.Name, entwicklung.Von, entwicklung.Zu
FROM pokemon JOIN entwicklung
ON pokemon.ID = entwicklung.Von;
    \end{minted}

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_definition_join_inner.txt}
\end{sql}

\begin{defi}{SELF JOIN}
    Als \texttt{SELF JOIN} werden \texttt{JOIN}s bezeichnet, welche eine reflexive Fremdschlüsselbeziehung abfragen.
    
    Hierbei ist zu beachten, dass \texttt{SELF} kein Keyword ist, sondern die reine Bezeichnung für solche Relationen.

    Dies wurde mit dem Beispiel \texttt{typ} auf \texttt{typ} bereits dargestellt.
\end{defi}

\begin{defi}{OUTER JOIN}
    \texttt{OUTER JOIN} berücksichtigt ebenfalls Entitäten, für die kein passendes Pendant existiert.
    Für diese Entitäten sind alle Attribute der jeweils anderen Entitätenmenge \texttt{NULL}.

    Ebenfalls \texttt{OUTER JOIN} ist keine gültige Abfrage.
    Das Keyword \texttt{OUTER} benötigt immer eine Leserichtung.

    Wenn wir erneut das Beispiel von \texttt{INNER JOIN} betrachten, sehen wir, dass das Pokémon mit der ID 3 nicht vorkommt.
    Dies ist dem Fakt geschuldet, dass dieses Pokémon keine Entwicklung besitzt.
    Sollte man dieses Pokemon trotzdem angezeigt bekommen, benötigt man \texttt{OUTER JOIN}.
\end{defi}

\begin{sql}{LEFT OUTER JOIN}
    \texttt{LEFT OUTER JOIN} beachtet alle Entitäten \emph{links} der Relation.

    Nun werden alle Pokémon dargestellt, ggf. mit \texttt{NULL}-Attributen bei Entwicklung:

    \begin{minted}{mysql}
SELECT
    pokemon.ID, pokemon.Name, entwicklung.Von, entwicklung.Zu
FROM pokemon LEFT OUTER JOIN entwicklung
ON pokemon.id = entwicklung.von;
    \end{minted}

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_sql_join_left_outer.txt}
\end{sql}

\begin{sql}{RIGHT OUTER JOIN}
    \texttt{RIGHT OUTER JOIN} beachtet alle Entitäten \emph{rechts} der Relation.

    Durch Vertauschen von Entitätstypen und Leserichtung erhält man äquivalente Befehle.

    So würde unser Beispiel aus \texttt{LEFT OUTER JOIN} folgendermaßen aussehen:

    \begin{minted}{mysql}
SELECT
    pokemon.ID, pokemon.Name, entwicklung.Von, entwicklung.Zu
FROM entwicklung RIGHT OUTER JOIN pokemon
ON pokemon.id = entwicklung.von;
    \end{minted}
\end{sql}

\begin{sql}{FULL OUTER JOIN}
    \texttt{FULL OUTER JOIN} ist eine \emph{Vereinigung} von \texttt{LEFT OUTER JOIN} und \texttt{RIGHT OUTER JOIN}.
    Das bedeutet, es sind alle Entitäten beider Seiten dabei, beidseitig ggf. mit \texttt{NULL} aufgefüllt\footnote{
    Manche DBMS bieten keinen Befehl für einen \texttt{FULL OUTER JOIN}.
    In diesem Fall vereinigt man die Ergebnisse der beiden \texttt{OUTER JOIN}s mit \texttt{UNION}.}.

    \begin{minted}{mysql}
SELECT
    pokemon.ID, pokemon.Name, entwicklung.Von, entwicklung.Zu
FROM pokemon FULL OUTER JOIN entwicklung
ON pokemon.id = entwicklung.von;

SELECT
    pokemon.ID, pokemon.Name, entwicklung.Von, entwicklung.Zu
FROM pokemon LEFT OUTER JOIN entwicklung
ON pokemon.id = entwicklung.von;
UNION
SELECT
    pokemon.ID, pokemon.Name, entwicklung.Von, entwicklung.Zu
FROM pokemon RIGHT OUTER JOIN entwicklung
ON pokemon.id = entwicklung.von;
    \end{minted}
\end{sql}

\begin{bonus}{NATURAL JOIN}
    Von der Verwendung von \texttt{NATURAL JOIN}s wird abgeraten!

    Bei Tabellen mit gleichnamigen Attributen kann auf die explizite Angabe der Bedingung verzichtet werden.
    Das DBMS verwendet dann \emph{alle} gleichnamigen Attribute.
\end{bonus}

\subsection{Beispiele}

\begin{example}{JOIN}
    Geben Sie für alle Pokemon jeweils die Entwicklung mit Level, sowie die Typen aus.

    Nutzen Sie:
    \begin{enumerate}[label=\alph*)]
        \item einen \texttt{INNER JOIN} mit \texttt{WHERE}
        \item einen \texttt{INNER JOIN} mit \texttt{JOIN}
    \end{enumerate}

    Fügen Sie noch den Namen, sowie die Typen der Entwicklung an.

    \exampleseparator

    \begin{enumerate}[label=\alph*)]
        \item \begin{minted}{mysql}
SELECT
    von.ID, von.Name, von.PrimaerTyp, von.SekundaerTyp,
    entwicklung.Level,
    zu.ID, zu.Name
FROM 
    pokemon AS von,
    pokemon AS zu,
    entwicklung
WHERE von.ID = entwicklung.Von AND entwicklung.Zu = zu.ID;
            \end{minted}
        \item \begin{minted}{mysql}
SELECT
    von.ID, von.Name, von.PrimaerTyp, von.SekundaerTyp,
    entwicklung.Level,
    zu.ID, zu.Name
FROM pokemon AS von
JOIN entwicklung ON von.ID = entwicklung.Von
JOIN pokemon AS zu ON entwicklung.Zu = zu.ID;
            \end{minted}
    \end{enumerate}
    
    \lstinputlisting[style=BashOutputStyle]{includes/code/out_example_join_inner.txt}
\end{example}

\begin{example}{JOIN}
    Geben Sie zusätzlich auch Pokémon aus, die (noch) keine Entwicklung haben.

    \exampleseparator

    \begin{minted}{mysql}
SELECT
    von.ID, von.Name, von.PrimaerTyp, von.SekundaerTyp,
    entwicklung.Level,
    zu.ID, zu.Name
FROM pokemon AS von
LEFT OUTER JOIN entwicklung ON von.ID = entwicklung.Von
LEFT OUTER JOIN pokemon AS zu ON entwicklung.Zu = zu.ID;
    \end{minted}

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_example_join_outer.txt}
\end{example}

\begin{example}{JOIN}
    Geben Sie alle Pokémon aus, welche bislang keine Entwicklung besitzen.

    \exampleseparator

    \begin{minted}{mysql}
SELECT
    pokemon.ID, pokemon.Name, pokemon.PrimaerTyp, pokemon.SekundaerTyp
FROM pokemon
LEFT OUTER JOIN entwicklung ON pokemon.ID = entwicklung.Von
WHERE entwicklung.Von IS NULL;
    \end{minted}

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_example_join_is_null.txt}
\end{example}

\begin{example}{JOIN}
    Geben Sie alle Pokémon aus, welche sich aus Evoli entwickeln.

    \exampleseparator

    \begin{minted}{mysql}
SELECT
    zu.ID, zu.Name, zu.PrimaerTyp, zu.SekundaerTyp,
    von.ID, von.Name
FROM pokemon AS zu
JOIN entwicklung ON zu.ID = entwicklung.Zu
JOIN pokemon AS von ON entwicklung.Von = von.ID
WHERE von.Name = 'Evoli';
    \end{minted}

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_example_join_evoli.txt}
\end{example}