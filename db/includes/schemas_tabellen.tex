\section{Schemas und Tabellen}

\begin{sql}{USE}
    \texttt{USE} legt ein Default-Schema fest.
    So kann bei Tabellen in SQL-Ausdrücken die explizite Angabe des Schemas entfallen.

    Möchte man also z.B. die Datenbank \texttt{db\_pokemon} auswählen, so nutzt man:

    \begin{lstlisting}[language=mysql]
        USE db_pokemon;
    \end{lstlisting}

    Folgend kann man den folgenden Befehl kürzen:

    \begin{lstlisting}[language=mysql]
        SELECT * FROM pokemon;
    \end{lstlisting}

    \begin{lstlisting}[language=mysql]
        SELECT * FROM !pokemon.!pokemon;
    \end{lstlisting}
\end{sql}

\begin{sql}{SHOW}
    \texttt{SHOW} wird genutzt um DBMS-spezifische Strukturen abzufragen.

    Dieser Befehl gibt eine Tabelle zurück.
    Dementsprechend lassen sich Projektionen sowie Selektionen auf das Ergebnis anwenden.

    Um alle Schemas bzw Datenbanken anzuzeigen nutzt man:

    \begin{lstlisting}[language=mysql]
        SHOW SCHEMAS;
    \end{lstlisting}

    \begin{lstlisting}[language=mysql]
        SHOW DATABASES;
    \end{lstlisting}

    \setcounter{rownum}{0}
    \begin{tabular}{I|T}
        \rowcolor{gray!35}
        & \multicolumn{1}{T}{Database} \\\hline
        1 & pokemon \\
    \end{tabular}

    Alternativ kann man sich innerhalb einer Datenbank alle Tabellen abfragen:

    \begin{lstlisting}[language=mysql]
        SHOW TABLES;
    \end{lstlisting}

    \begin{lstlisting}[language=mysql]
        SHOW TABLES !FROM pokemon!;
    \end{lstlisting}

    \setcounter{rownum}{0}
    \begin{tabular}{I|T}
        \rowcolor{gray!35}
        & \multicolumn{1}{T}{Tables\_in\_pokemon} \\\hline
        1 & arenaleiter \\
        2 & attacke \\
        3 & attacke\_tm \\
        4 & effektivitaet \\
        5 & entwicklung \\
        6 & generation \\
        7 & item \\
        8 & lernt \\
        9 & pokemon \\
        10 & typ \\
        11 & version \\
    \end{tabular}

    Um sich die Struktur einer Tabelle anzuzeigen nutzt man:

    \begin{lstlisting}[language=mysql]
        DESCRIBE pokemon; 
    \end{lstlisting}

    \begin{lstlisting}[language=mysql]
        SHOW COLUMNS FROM pokemon; 
    \end{lstlisting}

    \setcounter{rownum}{0}
    \begin{tabular}{I|TTTTTT}
        \rowcolor{gray!35}
        & \multicolumn{1}{T}{Field} & \multicolumn{1}{T}{Type} & \multicolumn{1}{T}{Null} & \multicolumn{1}{T}{Key} & \multicolumn{1}{T}{Default} & \multicolumn{1}{T}{Extra} \\\hline
        1 & ID & int & NO & PRI & NULL &  \\
        2 & Name & varchar(255) & NO &  & NULL &  \\
        3 & Groesse & float & NO &  & NULL &  \\
        4 & Gewicht & float & NO &  & NULL &  \\
        5 & Generation & int & NO & MUL & NULL &  \\
        6 & PrimaerTyp & varchar(255) & YES & MUL & NULL &  \\
        7 & SekundaerTyp & varchar(255) & YES & MUL & NULL &  \\
    \end{tabular}

    \begin{itemize}
        \item \emph{Field} ist dabei der Spaltenname
        \item \emph{Type} ist der Typ der Werte in der Spalte
        \item \emph{Null} gibt an, ob der Wert der Spalte NULL sein darf
        \item \emph{Key} gibt an, ob der Wert der Spalte ein
            
            \begin{itemize}
                \item \emph{PRI} Primärschlüssel
                \item \emph{MUL} Fremdschlüssel
            \end{itemize}

            ist.
    \end{itemize}
\end{sql}

\begin{sql}{DROP}
    \texttt{DROP} bzw. \texttt{DELETE} löscht DBMS-spezifische Strukturen.

    Wenn man die gesamte Datenbank pokemon löschen möchte, so nutzt man:

    \begin{lstlisting}[language=mysql]
        DROP DATABASE <Tabellenname>;
    \end{lstlisting}

    Möchte man die Tabelle \texttt{pokemon} löschen:

    \begin{lstlisting}[language=mysql]
        DROP TABLE <Tabellenname>;
    \end{lstlisting}
\end{sql}

\begin{sql}{CREATE}
    \texttt{CREATE} erstellt DBMS-spezifische Strukturen.

    Die Datenbank \texttt{pokemon} wurde wir folgt erstellt:

    \begin{lstlisting}[language=mysql]
        CREATE DATABASE pokemon;
    \end{lstlisting}

    Um Tabellen zu erstellen muss man die jeweilige Spalten beschreiben:

    \begin{lstlisting}[language=mysql]
        CREATE TABLE <Tabellenname> (
            <Spaltenname> [<Parameter>, ...],
            ...,
            PRIMARY KEY (<Spaltenname>, ..., <Spaltenname>),
            FOREIGN KEY (<Spaltenname>) REFERENCES <Tabellenname> (Spaltenname),
            ...
        );
    \end{lstlisting}

    Einige relevanten Parameter sind:

    \begin{itemize}
        \item \emph{Typ} beschreibt den Typen der Spaltenwerte.
            Die meisten Typen benötigen eine Länge; einige haben jedoch eine Standardlänge:
        
            \begin{itemize}
                \item \texttt{INT(n)} eine ganze Zahl der Länge n
                \item \texttt{FLOAT(n)} eine Zahl der Länge n
                \item \texttt{DECIMAL(n, m)} eine Zahl der Länge n mit m Nachkommastellen
                \item \texttt{CHAR(n)} ein String fester Länge n
                \item \texttt{VARCHAR(n)} ein String variabler Länge 0 bis n
                \item \texttt{BOOLEAN} bzw. \texttt{TINYINT(1)} speichert \texttt{TRUE} bzw. 1 oder \texttt{FALSE} bzw. 0
            \end{itemize}
        \item \texttt{DEFAULT} setzt einen Standardwert fest
        \item \texttt{UNIQUE} legt fest, ob der Wert einzigartig soll
        \item \texttt{NOT NULL} legt fest, ob der Wert \texttt{NULL} sein darf
        \item \texttt{CHECK(<Bedingung>)} Einzufügende Werte müssen die Bedingung erfüllen
    \end{itemize}

    Ein \texttt{PRIMARY KEY} ist ein Primärschlüssel, der die Entität eindeutig beschreibt.
    Dieser darf nie \texttt{NULL} sein.

    Ein \texttt{FOREIGN KEY} ist ein Fremdschlüssel, der Primärschlüssel einer anderen Entität referenziert.
\end{sql}

\begin{sql}{Zeit- und Datumstypen}
    Zusätzlich gibt es komplexere Typen, welche zur Speicherung von Daten genutzt werden:
    
    Dazu vorab:
    MySQL nutzt \texttt{session} und \texttt{global} Konfigurationen.

    Die \texttt{session} Konfiguration wird beim Abschalten der Datenbank auf \texttt{global} zurückgesetzt.

    \begin{lstlisting}[language=mysql]
        SELECT @@session.time_zone, @@global.time_zone;;
    \end{lstlisting}

    \setcounter{rownum}{0}
    \begin{tabular}{I|TT}
        \rowcolor{gray!35}
        & \multicolumn{1}{T}{@@session.time\_zone} & \multicolumn{1}{T}{@@global.time\_zone} \\\hline
        1 & SYSTEM & SYSTEM \\
    \end{tabular}

    Die Zeitzone kann mit folgendem Befehl angepasst werden:

    \begin{lstlisting}[language=mysql]
        SET SESSION TIME_ZONE = <Zeitzone>
    \end{lstlisting}

    Dabei kann als Zeitzone folgendes eingestellt werden:

    \begin{itemize}
        \item Eine exakte Zeitzone: \lstinline[language=mysql]{'Europe/Berlin'}
        \item Ein Offset: \lstinline[language=mysql]{'+02:00'}
    \end{itemize}

    Einige Datumstypen sind:

    \begin{itemize}
        \item \texttt{date}
        \item \texttt{time}
        \item \texttt{datetime}
    \end{itemize}

    Ein Cast in verschiedene Typen ist wie folgt möglich:\footnote{\texttt{NOW()} gibt das aktuelle Datum in der Formatierung \texttt{session.TIME\_ZONE} zurück}

    \begin{lstlisting}[language=mysql]
        SELECT
            NOW() AS 'Session',
            cast(NOW() AS DATE) AS 'Date',
            cast(NOW() AS TIME) AS 'Time',
            cast(NOW() AS DATETIME) AS 'Datetime';
    \end{lstlisting}

    \setcounter{rownum}{0}
    \begin{tabular}{I|TTTT}
        \rowcolor{gray!35}
        & \multicolumn{1}{T}{Session} & \multicolumn{1}{T}{Date} & \multicolumn{1}{T}{Time} & \multicolumn{1}{T}{Datetime} \\\hline
        1 & 1996-02-27 10:00:00 & 1996-02-27 & 10:00:00 & 1996-02-27 10:00:00 \\
    \end{tabular}

    Zusätzlich ist es ebenfalls möglich von Strings zu einem Datum zu casten:

    \begin{lstlisting}[language=mysql]
        SELECT
            STR_TO_DATE('27.02.1996', GET_FORMAT(DATE, 'EUR')) AS 'STR_TO_DATE',
            DATE_FORMAT(NOW(), GET_FORMAT(DATE, 'EUR')) AS 'DATE',
            -- %W = Wochentag, %D Tag im Monat, %M = Monat, %Y = Jahr
            DATE_FORMAT(NOW(), '%W, %D %M %Y') AS 'CUSTOMIZED DATE';
    \end{lstlisting}

    \setcounter{rownum}{0}
    \begin{tabular}{I|TTT}
        \rowcolor{gray!35}
        & \multicolumn{1}{T}{STR\_TO\_DATE} & \multicolumn{1}{T}{DATE} & \multicolumn{1}{T}{CUSTOMIZED\_DATE} \\\hline
        1 & 1996-02-27 & 27.02.1996 & Tuesday, 27th February 1996 \\
    \end{tabular}

    Ein Datum kann über \lstinline[language=mysql]{DATE_ADD()}, oder per \texttt{+} bzw. \texttt{-}, modifiziert werden:

    \begin{lstlisting}[language=mysql]
        SELECT
            NOW() !+! INTERVAL 1 YEAR,
            !DATE_ADD!(NOW(), INTERVAL 1 YEAR);
    \end{lstlisting}

    Alternativ kann ebenfalls eine Zeitspanne ermittelt werden:

    \begin{lstlisting}[language=mysql]
        SELECT
            DATEDIFF(DATE_ADD(NOW(), INTERVAL 1 YEAR), NOW()),
            TIMEDIFF(DATE_ADD(NOW(), INTERVAL 1 HOUR), NOW());
    \end{lstlisting}
\end{sql}

\begin{sql}{ALTER TABLE}
    \texttt{ALTER TABLE} modifiziert eine Tabelle.

    \texttt{ADD} wird genutzt, um Spalten hinzuzufügen.
    Die Syntax ist dabei identisch zu der Syntax beim Erstellen der Tabelle.

    \begin{lstlisting}[language=mysql]
        ALTER TABLE <Tabellenname>
        ADD (
            <Spaltenname> [<Parameter>, ...],
            ...
        );
    \end{lstlisting}

    \texttt{MODIFY} verändert existierende Spalten.

    \begin{lstlisting}[language=mysql]
        ALTER TABLE <Tabellenname>
        MODIFY <Spaltenname> [<Neuer Spaltenname>] [<Neuer Parameter>, ...];
    \end{lstlisting}

    \texttt{DROP} löscht angegebene Spalten.

    \begin{lstlisting}[language=mysql]
        ALTER TABLE <Tabellenname>
        DROP <Spaltenname>;
    \end{lstlisting}

    \texttt{RENAME TO} benennt Tabellen um.

    \begin{lstlisting}[language=mysql]
        ALTER TABLE <Tabellenname>
        RENAME TO <neuer Tabellenname>;
    \end{lstlisting}
\end{sql}

\subsection{Beispiele}

\begin{example}{Schemas und Tabellen}
    Die SQL Befehle, welche zur Erstellung unserer Beispieldatenbank genutzt wurden sind in \texttt{pokemon.sql} zu finden.

    Einige relevante Befehle für die DBMS-Struktur sind hier zusammengefasst:

    Falls \texttt{pokemon} existiert wird diese Tabelle gelöscht:

    \begin{lstlisting}[language=mysql]
        DROP TABLE IF EXISTS `pokemon`;
    \end{lstlisting}

    Im Nachhinein wird eine neue Tabelle erstellt:

    \begin{lstlisting}[language=mysql]
        CREATE TABLE `pokemon` (
            `ID` int(11) NOT NULL,
            `Name` varchar(255) NOT NULL,
            `Groesse` float NOT NULL,
            `Gewicht` float NOT NULL,
            `Generation` int(11) NOT NULL,
            `PrimaerTyp` varchar(255) DEFAULT NULL,
            `SekundaerTyp` varchar(255) DEFAULT NULL,
            PRIMARY KEY (`ID`),
            FOREIGN KEY (`PrimaerTyp`) REFERENCES `typ` (`Bezeichnung`),
            FOREIGN KEY (`SekundaerTyp`) REFERENCES `typ` (`Bezeichnung`),
            FOREIGN KEY (`Generation`) REFERENCES `generation` (`ID`)
        )
    \end{lstlisting}
\end{example}