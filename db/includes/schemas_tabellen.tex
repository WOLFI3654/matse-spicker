\section{Schemas und Tabellen}

\begin{sql}{USE}
    \texttt{USE} legt ein Default-Schema fest.
    So kann bei Tabellen in SQL-Ausdrücken die explizite Angabe des Schemas entfallen.

    Möchte man also z.B. die Datenbank \texttt{db\_pokemon} auswählen, so nutzt man:

    \begin{lstlisting}[language=mysql]
        USE db_pokemon;
    \end{lstlisting}

    Folgend kann man den folgenden Befehl kürzen:

    \begin{lstlisting}[language=mysql]
        SELECT * FROM pokemon;
    \end{lstlisting}

    \begin{lstlisting}[language=mysql]
        SELECT * FROM !pokemon.!pokemon;
    \end{lstlisting}
\end{sql}

\begin{sql}{SHOW}
    \texttt{SHOW} wird genutzt um DBMS-spezifische Strukturen abzufragen.

    Dieser Befehl gibt eine Tabelle zurück.
    Dementsprechend lassen sich Projektionen sowie Selektionen auf das Ergebnis anwenden.

    Um alle Schemas bzw Datenbanken anzuzeigen nutzt man:

    \begin{lstlisting}[language=mysql]
        SHOW SCHEMAS;
    \end{lstlisting}

    \begin{lstlisting}[language=mysql]
        SHOW DATABASES;
    \end{lstlisting}

    \setcounter{rownum}{0}
    \begin{tabular}{I|T}
        \rowcolor{gray!35}
        & \multicolumn{1}{T}{Database} \\\hline
        1 & pokemon \\
    \end{tabular}

    Alternativ kann man sich innerhalb einer Datenbank alle Tabellen abfragen:

    \begin{lstlisting}[language=mysql]
        SHOW TABLES;
    \end{lstlisting}

    \begin{lstlisting}[language=mysql]
        SHOW TABLES !FROM pokemon!;
    \end{lstlisting}

    \setcounter{rownum}{0}
    \begin{tabular}{I|T}
        \rowcolor{gray!35}
        & \multicolumn{1}{T}{Tables\_in\_pokemon} \\\hline
        1 & arenaleiter \\
        2 & attacke \\
        3 & attacke\_tm \\
        4 & effektivitaet \\
        5 & entwicklung \\
        6 & generation \\
        7 & item \\
        8 & lernt \\
        9 & pokemon \\
        10 & typ \\
        11 & version \\
    \end{tabular}

    Um sich die Struktur einer Tabelle anzuzeigen nutzt man:

    \begin{lstlisting}[language=mysql]
        DESCRIBE pokemon; 
    \end{lstlisting}

    \begin{lstlisting}[language=mysql]
        SHOW COLUMNS FROM pokemon; 
    \end{lstlisting}

    \setcounter{rownum}{0}
    \begin{tabular}{I|TTTTTT}
        \rowcolor{gray!35}
        & \multicolumn{1}{T}{Field} & \multicolumn{1}{T}{Type} & \multicolumn{1}{T}{Null} & \multicolumn{1}{T}{Key} & \multicolumn{1}{T}{Default} & \multicolumn{1}{T}{Extra} \\\hline
        1 & ID & int & NO & PRI & NULL &  \\
        2 & Name & varchar(255) & NO &  & NULL &  \\
        3 & Groesse & float & NO &  & NULL &  \\
        4 & Gewicht & float & NO &  & NULL &  \\
        5 & Generation & int & NO & MUL & NULL &  \\
        6 & PrimaerTyp & varchar(255) & YES & MUL & NULL &  \\
        7 & SekundaerTyp & varchar(255) & YES & MUL & NULL &  \\
    \end{tabular}

    \begin{itemize}
        \item \emph{Field} ist dabei der Spaltenname
        \item \emph{Type} ist der Typ der Werte in der Spalte
        \item \emph{Null} gibt an, ob der Wert der Spalte NULL sein darf
        \item \emph{Key} gibt an, ob der Wert der Spalte ein
            
            \begin{itemize}
                \item \emph{PRI} Primärschlüssel
                \item \emph{MUL} Fremdschlüssel
            \end{itemize}

            ist.
    \end{itemize}
\end{sql}

\begin{sql}{DROP}
    \texttt{DROP} bzw. \texttt{DELETE} löscht DBMS-spezifische Strukturen.

    Wenn man die gesamte Datenbank pokemon löschen möchte, so nutzt man:

    \begin{lstlisting}[language=mysql]
        DROP DATABASE <Tabellenname>;
    \end{lstlisting}

    Möchte man die Tabelle \texttt{pokemon} löschen:

    \begin{lstlisting}[language=mysql]
        DROP TABLE <Tabellenname>;
    \end{lstlisting}
\end{sql}

\begin{sql}{CREATE}
    \texttt{CREATE} erstellt DBMS-spezifische Strukturen.

    Die Datenbank \texttt{pokemon} wurde wir folgt erstellt:

    \begin{lstlisting}[language=mysql]
        CREATE DATABASE pokemon;
    \end{lstlisting}

    Um Tabellen zu erstellen muss man die jeweilige Spalten beschreiben:

    \begin{lstlisting}[language=mysql]
        CREATE TABLE <Tabellenname> (
            <Spaltenname> [<Parameter>, ...],
            ...,
            PRIMARY KEY (<Spaltenname>, ..., <Spaltenname>),
            FOREIGN KEY (<Spaltenname>) REFERENCES <Tabellenname> (Spaltenname),
            ...
        );
    \end{lstlisting}

    Einige relevanten Parameter sind:

    \begin{itemize}
        \item \emph{Typ} beschreibt den Typen der Spaltenwerte.
            Die meisten Typen benötigen eine Länge; einige haben jedoch eine Standardlänge:
        
            \begin{itemize}
                \item \texttt{INT(n)} eine ganze Zahl der Länge n
                \item \texttt{FLOAT(n)} eine Zahl der Länge n
                \item \texttt{DECIMAL(n, m)} eine Zahl der Länge n mit m Nachkommastellen
                \item \texttt{CHAR(n)} ein String fester Länge n
                \item \texttt{VARCHAR(n)} ein String variabler Länge 0 bis n
                \item \texttt{BOOLEAN} bzw. \texttt{TINYINT(1)} speichert \texttt{TRUE} bzw. 1 oder \texttt{FALSE} bzw. 0
                \item \texttt{DATETIME} wird genutzt, um ein Datum zu speichern\footnote{\texttt{NOW()} trägt das aktuelle Datum beim Erstellen der Wertes ein}
            \end{itemize}
        \item \texttt{DEFAULT} setzt einen Standardwert fest
        \item \texttt{UNIQUE} legt fest, ob der Wert einzigartig soll
        \item \texttt{NOT NULL} legt fest, ob der Wert \texttt{NULL} sein darf
    \end{itemize}

    Ein \texttt{PRIMARY KEY} ist ein Primärschlüssel, der die Entität eindeutig beschreibt.
    Dieser darf nie \texttt{NULL} sein.

    Ein \texttt{FOREIGN KEY} ist ein Fremdschlüssel, der Primärschlüssel einer anderen Entität referenziert.
\end{sql}

\begin{sql}{ALTER TABLE}
    \texttt{ALTER TABLE} modifiziert eine Tabelle.

    \texttt{ADD} wird genutzt, um Spalten hinzuzufügen.
    Die Syntax ist dabei identisch zu der Syntax beim Erstellen der Tabelle.

    \begin{lstlisting}[language=mysql]
        ALTER TABLE <Tabellenname>
        ADD (
            <Spaltenname> [<Parameter>, ...],
            ...
        );
    \end{lstlisting}

    \texttt{MODIFY} verändert existierende Spalten.

    \begin{lstlisting}[language=mysql]
        ALTER TABLE <Tabellenname>
        MODIFY <Spaltenname> [<Neuer Spaltenname>] [<Neuer Parameter>, ...];
    \end{lstlisting}

    \texttt{DROP} löscht angegebene Spalten.

    \begin{lstlisting}[language=mysql]
        ALTER TABLE <Tabellenname>
        DROP <Spaltenname>;
    \end{lstlisting}

    \texttt{RENAME TO} benennt Tabellen um.

    \begin{lstlisting}[language=mysql]
        ALTER TABLE <Tabellenname>
        RENAME TO <neuer Tabellenname>;
    \end{lstlisting}
\end{sql}

\subsection{Beispiele}

\begin{example}{Schemas und Tabellen}
    Die SQL Befehle, welche zur Erstellung unserer Beispieldatenbank genutzt wurden sind in \texttt{pokemon.sql} zu finden.

    Einige relevante Befehle für die DBMS-Struktur sind hier zusammengefasst:

    Falls \texttt{pokemon} existiert wird diese Tabelle gelöscht:

    \begin{lstlisting}[language=mysql]
        DROP TABLE IF EXISTS `pokemon`;
    \end{lstlisting}

    Im Nachhinein wird eine neue Tabelle erstellt:

    \begin{lstlisting}[language=mysql]
        CREATE TABLE `pokemon` (
            `ID` int(11) NOT NULL,
            `Name` varchar(255) NOT NULL,
            `Groesse` float NOT NULL,
            `Gewicht` float NOT NULL,
            `Generation` int(11) NOT NULL,
            `PrimaerTyp` varchar(255) DEFAULT NULL,
            `SekundaerTyp` varchar(255) DEFAULT NULL,
            PRIMARY KEY (`ID`),
            FOREIGN KEY (`PrimaerTyp`) REFERENCES `typ` (`Bezeichnung`),
            FOREIGN KEY (`SekundaerTyp`) REFERENCES `typ` (`Bezeichnung`),
            FOREIGN KEY (`Generation`) REFERENCES `generation` (`ID`)
        )
    \end{lstlisting}
\end{example}