\section{Selektion, Projektion}

\begin{sql}{USE}
    \texttt{USE} legt ein Default-Schema fest.
    So kann bei Tabellen in SQL-Ausdrücken die explizite Angabe des Schemas entfallen.

    Möchte man also z.B. die Datenbank \texttt{db\_pokemon} auswählen, so nutzt man:

    \begin{minted}{mysql}
USE db_pokemon;
    \end{minted}
\end{sql}

\begin{defi}{Projektion}
    Eine \emph{Projektion} wählt Spalten durch Angabe von Attributen der Tabelle.
\end{defi}

\begin{defi}{Selektion}
    Eine \emph{Selektion} filtert Zeilen durch Angabe eines Kriteriums, welches je Zeile erfüllt sein muss.
\end{defi}

\begin{sql}{SELECT}
    \texttt{SELECT} gibt alle Datensätze einer Tabelle aus.

    Möchte man sich z.B. alle Pokémon aus der Tabelle \texttt{pokemon} anzeigen lassen, so nutzt man:

    \mint{mysql}|SELECT * FROM pokemon;|

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_code_select_all.txt}

    Möchte man eine \emph{Projektion} auf die Ergebnisse der Abfrage anwenden, sich also nur bestimmte Spalten anzeigen lassen, kann man dies im \texttt{SELECT} spezifizieren\footnote{Der \texttt{*} dient als Platzhalter für alle Attribute}:

    \mint{mysql}|SELECT ID, Name, PrimaerTyp, SekundaerTyp FROM pokemon;|

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_code_select_projektion.txt}

    Die Reihenfolge der Datensätzer ist hierbei nicht vorgegeben.
\end{sql}

\begin{sql}{WHERE}
    Möchte man eine \emph{Selektion} auf die Ergebnisse der Abfrage anwenden, also für jedes Element eine Bedingung vorraussetzen, nutzt man \texttt{WHERE}.

    Beispielsweise werden im folgendem Befehl alle Pokémon mit dem Typ Feuer ausgegeben:

    \mint{mysql}|SELECT * FROM pokemon WHERE PrimaerTyp = 'Feuer';|

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_code_select_where.txt}
\end{sql}

\begin{sql}{AS}
    Um komplexere Ausdrücke zu kürzen oder Zweideutigkeiten aufzulösen, kann man Tabellen mit einem \emph{Alias} versehen.

    Beispielsweise wäre im folgenden Befehl die Tabelle \texttt{pokemon} unter \texttt{p} erreichbar:

    \mint{mysql}|SELECT p.* FROM pokemon AS p;|

    Das Schlüsselwort \texttt{AS} ist optional, d.h folgende Abfrage ist äquivalent:
    
    \mint{mysql}|SELECT p.* FROM pokemon p;|
\end{sql}

\begin{sql}{ORDER BY}
    \texttt{ORDER BY} sortiert die Ergebnismenge nach Kriterien auf- (\texttt{ASC}) oder absteigend (\texttt{DESC}).
    
    Sollten mehrere Kriterien angegeben sein, so wird die Menge nach dem ersten gegebenen Kriterium sortiert.
    Wenn nach diesem Schritt mehrere Einträge dieses Kriterium gleichermaßen erfüllen, wird diese Untermenge nach dem zweiten Kriterium sortiert, usw.

    \texttt{NULL} ist immer der erste Eintrag.
    
    Wenn man sich also alle Pokémon nach Namen sortiert ausgeben möchte, so erhält man\footnote{ASC ist dabei der \texttt{Default} Wert}:

    \begin{minted}{mysql}
SELECT * FROM pokemon ORDER BY Name;
SELECT * FROM pokemon ORDER BY Name ASC;
    \end{minted}

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_bonus_select_order_by_name.txt}

    Wenn man alternativ alle Pokémon erst nach Primärtyp (\texttt{ASC}), dann nach Sekundärtyp (\texttt{DESC}) sortiert ausgeben möchte, erhält man:

    \mint{mysql}|SELECT * FROM pokemon ORDER BY PrimaerTyp ASC, SekundaerTyp DESC;|

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_bonus_select_order_by_typ.txt}
\end{sql}

\subsection{Funktionen}

\begin{sql}{CONCAT}
    \texttt{CONCAT} kombiniert verschiedene Strings zu einem.

    In folgendem Beispiel werden Primärtyp und Sekundärtyp zu einem Eintrag zusammengefasst:

    \begin{minted}{mysql}
SELECT
    ID, Name,
    CONCAT('[', PrimaerTyp, ', ', SekundaerTyp, ']') AS 'Typ'
FROM pokemon
    WHERE SekundaerTyp IS NOT NULL;
    \end{minted}

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_bonus_select_concat.txt}
\end{sql}

\begin{sql}{ROUND}
    \texttt{ROUND} rundet numerische Werte.
    Der zweite Parameter gibt die gewünschte Anzahl an Nachkommastellen an.

    In folgendem Beispiel wird das Gewicht eines Pokémon auf ganzzahlige Werte gerundet:

    \begin{minted}{mysql}
SELECT
    ID, Name, Gewicht,
    ROUND(Gewicht, 0)
FROM pokemon;
    \end{minted}

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_bonus_select_round.txt}
\end{sql}

\begin{sql}{COUNT}
    \texttt{COUNT} zählt alle nicht-\texttt{NULL} Datensätze.
    Sollte \texttt{*} angegeben werden, beachtet er alle Entitäten, welche mindestens ein nicht-\texttt{NULL} Attribut besitzen.

    Dudurch, dass \texttt{ID} und \texttt{PrimaerTyp} nicht \texttt{NULL} sein können, erhält man mit folgenden äquivalenten Befehlen die Anzahl aller Pokémon:

    \begin{minted}{mysql}
SELECT COUNT(*) FROM pokemon;
SELECT COUNT(ID) FROM pokemon;
SELECT COUNT(PrimaerTyp) FROM pokemon;
    \end{minted}

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_bonus_select_count_all.txt}

    Möchten wir nun alle Pokémon mit einem Sekundärtypen zählen, so erhalten wir: 

    \mint{mysql}|SELECT COUNT(SekundaerTyp) FROM pokemon;|

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_bonus_select_count.txt}
\end{sql}

\subsection{Operatoren}

\begin{sql}{IS NULL}
    \texttt{IS NULL} bzw. \texttt{IS NOT NULL} werden genutzt, um mit \texttt{NULL}-Einträgen zu arbeiten.

    In der folgenden Abfrage werden Pokémon mit exakt einem Typen zurückgegeben:

    \begin{minted}{mysql}
SELECT
    ID, Name, PrimaerTyp, SekundaerTyp
FROM pokemon
    WHERE SekundaerTyp IS NULL;
    \end{minted}

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_bonus_select_null.txt}
\end{sql}

\begin{sql}{COALESCE}
    \texttt{COALESCE} gibt den ersten nicht-\texttt{NULL} Eintrag aus der Parameterliste zurück.
    Dementsprechend sind folgende SQL-Befehle äquivalent:

    \begin{minted}{mysql}
SELECT 'Ausgabe' AS 'Beispiel';
SELECT COALESCE(NULL, NULL, ..., NULL, 'Ausgabe') AS 'Beispiel';
    \end{minted}

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_bonus_select_coalesce_ausgabe.txt}

    In diesem Beispiel wird aus der Tabelle \texttt{entwicklung} jede \texttt{NULL}-Tageszeit mit dem String \texttt{Immer} ersetzt:

    \begin{minted}{mysql}
SELECT
    Von, Zu, Tageszeit,
    COALESCE(Tageszeit, 'Immer') AS Entwicklungszeitraum
FROM entwicklung;
    \end{minted}

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_bonus_select_coalesce.txt}
\end{sql}

\begin{sql}{Bedingungen}
    \emph{Bedingungen} werden von Selektionen, sowie von \texttt{IF}-Abfragen genutzt:

    \begin{minted}{mysql}
SELECT * FROM <Tabelle> WHERE <Bedingung>;
SELECT IF(<Bedingung>, <Wert wenn TRUE>, <Wert wenn FALSE>);
    \end{minted}

    Verschiedene Bedingungen lassen sich mit \texttt{AND} und \texttt{OR} verbinden, sowie mit \texttt{NOT} negieren.

    Operatoren, welche für die meisten Datentypen definiert sind:

    \begin{itemize}
        \item \texttt{=} überprüft auf exakte Gleichheit.
        \item \texttt{IN} überprüft, ob der Wert in einer angegebenen Liste zu finden ist.
    \end{itemize}

    Explizit für String Werte ist definiert:

    \begin{itemize}
        \item \texttt{LIKE}: Benutzt reguläre Ausdrücke zum Vergleichen:
            \begin{itemize}
                \item \texttt{\%} lässt beliebig viele beliebige Zeichen zu.
                \item \texttt{\_} lässt exakt ein beliebiges Zeichen zu.
            \end{itemize}
    \end{itemize}

    Des Weiteren kann man für numerische Werte folgende Operatoren nutzen:

    \begin{itemize}
        \item \texttt{$<$, $<=$, $>$, $>=$}
        \item \texttt{BETWEEN X AND Y} überprüft, ob der Wert zwischen den angegebenen Grenzen \texttt{X} und \texttt{Y} (beide inklusive) liegt.
    \end{itemize}

    Achtung: Ausdrücke sind \texttt{NULL}, wenn einer der Operanden \texttt{NULL} ist.
\end{sql}

\begin{sql}{DISTINCT}
    \texttt{DISTINCT} berücksichtigt keine doppelten Daten.

    Wenn man sich jede vorhandene Kombination an Typen anzeigen lassen möchte, so erhält man in folgender Abfrage doppelte Werte:

    \mint{mysql}|SELECT PrimaerTyp, SekundaerTyp FROM pokemon;|

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_bonus_select_distinct_all.txt}

    Diese entfallen, wenn man das Schlüsselwort \texttt{DISTINCT} ergänzt:

    \mint{mysql}|SELECT DISTINCT PrimaerTyp, SekundaerTyp FROM pokemon;|

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_bonus_select_distinct.txt}
\end{sql}

\subsection{Beispiele}

\begin{example}{SELECT}
    Ermitteln Sie, wieviele verschiedene Typkombinationen in der Tabelle \texttt{pokemon} vorhanden sind und geben Sie die Anzahl aus.

    \exampleseparator

    \begin{minted}{mysql}
SELECT
    COUNT(
        DISTINCT PrimaerTyp,
        COALESCE(SekundaerTyp, 'NULL')
    )
FROM pokemon;
    \end{minted}

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_example_select_typ.txt}
\end{example}

\begin{example}{SELECT}
    Ermitteln Sie den BMI\footnote{$\text{BMI} = \frac{\text{Gewicht}}{\text{Größe}^2}$} aller Pokémon, welche mehr als 50kg wiegen.
    
    Runden Sie das Ergebnis auf 2 Nachkommastellen.

    \exampleseparator

    \begin{minted}{mysql}
SELECT
    ID, Name, Gewicht, Groesse,
    ROUND(Gewicht / (Groesse * Groesse), 2) AS BMI
FROM pokemon
    WHERE Gewicht > 50
    ORDER BY BMI DESC;
    \end{minted}

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_example_select_bmi.txt}
\end{example}

\begin{example}{SELECT}
    Wieviele Pokémon-namen beginnen mit einem \texttt{P}?
    
    Und wieviele enthalten ein \texttt{P}?
    
    Ermitteln Sie die jeweilige Anzahl.

    \exampleseparator

    \mint{mysql}|SELECT COUNT(*) FROM pokemon WHERE Name LIKE 'P%';|

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_example_select_count_p_start.txt}

    \mint{mysql}|SELECT COUNT(*) FROM pokemon WHERE Name LIKE '%P%';|

    \lstinputlisting[style=BashOutputStyle]{includes/code/out_example_select_count_p_in.txt}
\end{example}